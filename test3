import { Injectable } from '@angular/core';
import { CanMatch, Route, Router, UrlSegment, UrlTree } from '@angular/router';
import { AuthService } from './auth.service';
import { UserService } from '../core/user.service';
import { isOidcCallbackUrl, log } from './auth.util';
import { CtxPolicy, policyFromRouteData, normalizeCleanUrl } from './guard-utils';

@Injectable({ providedIn: 'root' })
export class AuthMatchGuard implements CanMatch {
  constructor(
    private auth: AuthService,
    private user: UserService,
    private router: Router
  ) {}

  async canMatch(route: Route, segments: UrlSegment[]): Promise<boolean | UrlTree> {
    // Use the FULL current URL so child segments are preserved (e.g., /funding/return)
    const currentUrl = window.location.pathname + window.location.search + window.location.hash;

    // 1) Let OIDC callback through so the SDK can finish code flow
    if (isOidcCallbackUrl()) { log('GUARD', 'callback → pass (match)', { currentUrl }); return true; }

    // 2) Auth check
    if (!(this.auth.isReady() && this.auth.accessToken())) {
      log('GUARD', 'not auth → start login (match)', { returnUrl: currentUrl });
      await this.auth.startLoginWithState();
      return false;
    }

    // 3) Context policy (default 'both'); outliers: 'ctxOnly' | 'none'
    const policy: CtxPolicy = policyFromRouteData(route.data);
    const { loanno, contexttype } = this.user.context();
    log('GUARD', 'policy (match)', { policy, loanno, contexttype, currentUrl });

    // Missing-required → /settings
    if (policy === 'both' && (!loanno || !contexttype)) {
      log('GUARD', 'missing both → /settings (match)');
      return this.router.parseUrl('/settings');
    }
    if (policy === 'ctxOnly' && !contexttype) {
      log('GUARD', 'missing ctxOnly → /settings (match)');
      return this.router.parseUrl('/settings');
    }

    // 4) Clean-URL normalization (remove disallowed params; never add)
    const next = normalizeCleanUrl(currentUrl, policy);
    if (currentUrl !== next) {
      log('GUARD', 'normalize (clean/match)', { from: currentUrl, to: next });
      return this.router.parseUrl(next);
    }

    log('GUARD', 'pass (match)');
    return true;
  }
}
