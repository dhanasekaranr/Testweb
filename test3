If you already “wait for first login” in the guard, make sure it’s doing the right kind of waiting and not kicking off refresh during init. Here’s a tight, production-safe pattern you can drop in.

AuthService (idempotent init + ready barrier, no refresh during init)
// auth.service.ts
import { Injectable } from '@angular/core';
import { OAuthService } from 'angular-oauth2-oidc';
import { authConfig } from './oauth.config';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private initPromise?: Promise<void>;
  private ready = false;

  constructor(private oauth: OAuthService) {}

  /** Call from APP_INITIALIZER OR from the guard (it’s idempotent). */
  initOnce(): Promise<void> {
    if (this.initPromise) return this.initPromise;
    this.initPromise = this.initFlow();
    return this.initPromise;
  }

  private async initFlow(): Promise<void> {
    this.oauth.configure(authConfig);
    await this.oauth.loadDiscoveryDocumentAndTryLogin();      // handles ?code=&state=
    if (!this.oauth.hasValidAccessToken()) {
      // Do NOT try to refresh here—no token yet.
      // Let the guard decide whether to trigger interactive login.
      return;
    }
    this.ready = true;
    this.scheduleProactive();                                 // set timer only after tokens exist
  }

  isReady(): boolean { return this.ready; }
  hasToken(): boolean { return this.oauth.hasValidAccessToken(); }
  get expiresAt(): number { return this.oauth.getAccessTokenExpiration(); }
  get hasRefreshToken(): boolean { return !!(this.oauth as any).getRefreshToken?.(); }

  async login(): Promise<void> { await this.oauth.initLoginFlow(); }  // redirect

  async ensureValidToken(): Promise<void> {
    // Hard guards: never refresh during init; never refresh without tokens.
    if (!this.ready || !this.hasToken() || !this.hasRefreshToken) return;

    const exp = this.expiresAt;
    if (!exp || Date.now() + 60_000 < exp) return;            // >60s left → skip
    await this.oauth.refreshToken();
  }

  private scheduleProactive(): void {
    const exp = this.expiresAt;
    if (!exp || !this.hasRefreshToken) return;
    const delay = Math.max(0, exp - Date.now() - 60_000);
    setTimeout(() => { void this.ensureValidToken(); }, delay);
  }
}

Helper to detect “implicit callback” (no dedicated route)
// auth.util.ts
export function isOidcCallbackUrl(): boolean {
  const q = window.location.search || '';
  const h = window.location.hash || '';
  return /[?&]code=/.test(q) || /[?&]state=/.test(q) || /[#&]code=/.test(h) || /[#&]state=/.test(h);
}

Auth Guard (waits for first login correctly)

Waits for initOnce() to finish

Skips itself on the OIDC callback load

If still no token → kicks off interactive login (redirect) and returns false

If token exists → ensures freshness (but never during init)

// auth.guard.ts (Angular 15+ functional guard)
import { inject } from '@angular/core';
import { CanActivateFn } from '@angular/router';
import { AuthService } from './auth.service';
import { isOidcCallbackUrl } from './auth.util';

export const authGuard: CanActivateFn = async () => {
  const auth = inject(AuthService);

  if (isOidcCallbackUrl()) return true;               // let the lib finish the code flow

  await auth.initOnce();                               // idempotent; waits for discovery+tryLogin

  if (!auth.hasToken()) {
    await auth.login();                                // redirect to IdP
    return false;                                      // navigation stops until you come back
  }

  await auth.ensureValidToken();                       // near-expiry → RT refresh
  return true;
};

Interceptor: skip OAuth endpoints & callback
// auth.interceptor.ts
private isAuthUrl(url: string): boolean {
  return url.includes('/.well-known/')
      || url.includes('/authorize')
      || url.includes('/token')
      || url.includes('/logout');
}

intercept(req, next) {
  if (this.isAuthUrl(req.url) || isOidcCallbackUrl()) {
    return next.handle(req);                           // never touch OIDC traffic/callback load
  }
  // Optional: ensure freshness on normal API calls (auth.ensureValidToken has guards)
  return from(this.auth.ensureValidToken()).pipe(
    switchMap(() => next.handle(this.attach(req)))
  );
}

Why this fixes your “wait for first login” issues

Your guard’s “wait” is initOnce(), not refresh. It completes discovery + tryLogin and only then decides.

You don’t call ensureValidToken() while init is running (when exp is unknown/0).

The guard does not run on the OIDC callback load (code/state present), so you avoid loops.

Interceptor ignores OIDC endpoints and the callback pass, preventing recursion and “unknown error” masking.

If you already have an APP_INITIALIZER calling auth.initOnce(), keep it—it’ll resolve before the guard ever runs. If you don’t, the guard itself does the waiting safely.
