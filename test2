import {
  Component, Input, OnInit, OnChanges, SimpleChanges, forwardRef, Output, EventEmitter
} from '@angular/core';
import { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';
import { Store } from '@ngrx/store';
import { Observable } from 'rxjs';
import { selectLookupByName, selectLoading, selectError } from '../../state/lookup/lookup.selectors';
import { LookupItem } from '../../models/lookup.model';

@Component({
  selector: 'app-lookup-select',
  template: `
    <mat-form-field appearance="fill">
      <mat-label>{{ label }}</mat-label>
      <mat-select
        [disabled]="(loading$ | async) || disabled"
        [value]="selectedValue"
        (selectionChange)="onChange($event.value)"
      >
        <mat-option *ngFor="let item of items$ | async; trackBy: trackByFn" [value]="item.name">
          {{ item.value }}
        </mat-option>
      </mat-select>
      <button mat-icon-button *ngIf="allowReload" aria-label="Reload" (click)="onReload()">
        <mat-icon>refresh</mat-icon>
      </button>
    </mat-form-field>
    <mat-error *ngIf="(error$ | async)">{{ (error$ | async) }}</mat-error>
  `,
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => LookupSelectComponent),
      multi: true
    }
  ]
})
export class LookupSelectComponent implements OnInit, OnChanges, ControlValueAccessor {
  /** Optimize rendering by tracking items by their unique name */
  trackByFn(index: number, item: LookupItem): string {
    return item.name;
  }
  /** Name of the lookup to load */
  @Input() lookupName!: string;
  /** Initial selected value */
  @Input() selectedValue?: string;
  /** Optional filter params */
  @Input() params?: Record<string, any>;
  /** Form field label */
  @Input() label = 'Select';
  /** Show reload button */
  @Input() allowReload = false;

  /** Emits when user clicks reload button */
  @Output() reload = new EventEmitter<void>();

  items$!: Observable<LookupItem[]>;
  loading$!: Observable<boolean>;
  error$!: Observable<any>;

  disabled = false;

  private onTouched: () => void = () => {};
  private onChanged: (v: any) => void = () => {};

  constructor(private store: Store) {}

  ngOnInit() {
    this.load();
  }

  ngOnChanges(changes: SimpleChanges) {
    if (changes.lookupName || changes.params) {
      this.load();
    }
    if (changes.selectedValue) {
      this.value = this.selectedValue;
    }
  }

  private load() {
    this.store.dispatch(loadLookup({ lookupName: this.lookupName, params: this.params }));
    this.items$ = this.store.select(selectLookupByName(this.lookupName, this.params));
    this.loading$ = this.store.select(selectLoading);
    this.error$ = this.store.select(selectError);
  }

  writeValue(obj: any): void {
    this.value = obj;
  }

  registerOnChange(fn: any): void {
    this.onChanged = fn;
  }

  registerOnTouched(fn: any): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    this.disabled = isDisabled;
  }

  onChange(v: any) {
    this.value = v;
    this.onChanged(v);
    this.onTouched();
  }

  /** Emit reload event; caller should handle dispatch */
  onReload() {
    this.reload.emit();
  }
}
