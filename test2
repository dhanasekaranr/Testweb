VB6 → Angular 21 UI Generator
End-to-end setup: Custom Agents + Agent Skills + VS Code Extension Tools

This doc is written so your VS Code extension developer can implement the full workflow without guessing.

1) What you’re building

You’re building a tool-driven conversion system:

Custom Agents orchestrate steps and enforce guardrails (who does what + which tools they can use). Custom agents are .agent.md files (YAML frontmatter + instructions body) and VS Code discovers them from .github/agents.

Agent Skills provide reusable domain playbooks (mapping rules, examples, scripts/resources) loaded only when relevant. Skills live under .github/skills/<skill>/SKILL.md and are preview in VS Code (requires enabling a setting).

VS Code Extension contributes Language Model Tools (tool-calling functions like extractScreenSpec, generateAngularUi, etc.) that agents invoke. Tools must be declared in package.json and registered at runtime.

Non-negotiable architecture: agents don’t “hand-write Angular screens.” They call your deterministic tools that generate config-driven UI using your shared primitives.

2) Prerequisites
2.1 VS Code / Copilot requirements

Custom Agents are available starting VS Code 1.106.

Agent Skills support in VS Code is preview and requires enabling chat.useAgentSkills.

Developers should use the model picker to choose models per task; premium models may have a multiplier/cost indicator.

2.2 Extension requirements

Your extension must implement Language Model Tools API and/or a Chat Participant (optional).

Tools are invokable through vscode.lm.invokeTool(...) and inputs are validated against the tool schema declared in package.json.

3) Repo layout (what lives in the application repo)

Create these folders in the migration repo (not the extension repo):

.github/
  agents/
    vb6-ui-analyzer.agent.md
    screen-spec-refiner.agent.md
    angular-ui-generator.agent.md
    ui-kit-gatekeeper.agent.md
    ui-fix-and-stabilize.agent.md

  skills/
    vb6-angular-ui/
      SKILL.md
      mapping/
        vb-control-map.md
        split-strategy.md
      examples/
        golden-screens/
          tabbed-form/
          table-heavy/
          mixed/
      templates/
        config-snippets.md
        naming-rules.md
      contracts/
        page-layout.contract.md
        shared-tab-group.contract.md
        form-builder.contract.md
        shared-mat-table.contract.md

  copilot-instructions.md
  instructions/
    angular-ui.instructions.md
    forbidden-patterns.instructions.md

ui-kit-catalog/
  components/
  golden-screens/
  schemas/
  patterns/


Why this split

.github/agents = workflow personas + tool permissions. VS Code detects .md files in that folder as agents.

.github/skills = domain playbook + examples + resources (loaded only when needed).

copilot-instructions.md / .github/instructions/* = always-on standards (different from skills).

ui-kit-catalog = your real contracts/schemas/golden references used by the tools.

4) Enable Agent Skills in VS Code (one-time per developer)

Open VS Code Settings

Enable chat.useAgentSkills

Reload VS Code

Verify skills are discovered: Copilot uses the name and description from each SKILL.md frontmatter to decide relevance.

5) Custom Agent setup (what files to create)
5.1 Agent file rules (what VS Code expects)

A custom agent is a Markdown file with optional YAML frontmatter. Frontmatter supports fields like name, description, tools, model, target, and handoffs. You can reference tools in the body using #tool:<tool-name>.

Important: if a tool in the agent file isn’t available, VS Code ignores it.

5.2 Recommended agent lineup (and what each one does)
Agent	Job	Allowed tools	Output
VB6 UI Analyzer	Parse .frm + events to a clean parse-model and initial ScreenSpec	extractScreenSpec, read-only helpers	generated/<screenId>/screen.spec.json
ScreenSpec Refiner	Normalize naming, apply split strategy (tabs → child components), fill mapping gaps	refineScreenSpec, validateUiConfigs	Updated ScreenSpec (deterministic)
Angular UI Generator	Generate Angular wrapper + configs using shared primitives	generateAngularUi, applyWorkspaceEdits	apps/.../<screenId>/*
UI Kit Gatekeeper	Enforce compliance + schema validation + quality gates	validateUiConfigs, runAngularGates	pass/fail + report
Fix & Stabilize	Minimal diffs to fix gates; no refactors	patchAngularUi, runAngularGates	small patch PR-ready

You can add more agents later, but start with these 5 so output stays predictable.

6) Skill setup (what the SKILL contains)
6.1 Skill file format + location

A skill is a directory under .github/skills/<skill>/ containing SKILL.md with YAML frontmatter (name, description). VS Code recommends .github/skills and also supports personal skills in user profile locations.

6.2 What your skill must include

Your vb6-angular-ui skill should contain:

Mapping rules: VB controls → Shared primitives

Split strategy: how to turn one VB .frm into parent + child tab components

Golden screens: canonical examples the generator must match

Contracts: config schema expectations for PageLayout/TabGroup/FormBuilder/SharedMatTable

Anti-patterns: what to never generate (raw Material tabs/tables/forms, bespoke reactive form templates)

Copilot loads skills progressively (metadata → body → referenced resources), which is why skills work well for a big UI kit.

7) VS Code extension: how to wire agents/skills into real generation
7.1 The extension’s responsibility

Your extension provides deterministic, testable functions as tools:

extractScreenSpec(frmPath) → screen.spec.json

refineScreenSpec(screenSpecPath, options) → updated spec

generateAngularUi(screenSpecPath, targetFeaturePath) → files

validateUiConfigs(targetPath/specPath) → report

runAngularGates(appOrWorkspace) → lint/build/test results

writeMigrationReport(...) → markdown report

Agents then call these via tool calling. Tools in VS Code can be extension tools, built-in tools, or MCP tools.

7.2 Tool calling API (must-do items)

Declare tools in package.json under the languageModelTools contribution point.

Register tools at runtime with vscode.lm.registerTool(...).

Optionally, your chat participant can invoke tools using vscode.lm.invokeTool(...).

7.3 Minimal package.json tool contribution (example)

(Tool names below are placeholders; match your real tool IDs and reference names.)

{
  "contributes": {
    "languageModelTools": [
      {
        "name": "vb6ui_extractScreenSpec",
        "toolReferenceName": "extractScreenSpec",
        "displayName": "Extract ScreenSpec from VB6 Form",
        "canBeReferencedInPrompt": true,
        "inputSchema": {
          "type": "object",
          "properties": {
            "frmPath": { "type": "string", "description": "Absolute path to .frm file" }
          },
          "required": ["frmPath"]
        }
      }
    ]
  }
}


Tools must be registered in package.json and also registered in code.

7.4 Tool registration in extension.ts (example)
import * as vscode from 'vscode';
import { ExtractScreenSpecTool } from './tools/extractScreenSpec.tool';

export function activate(ctx: vscode.ExtensionContext) {
  ctx.subscriptions.push(
    vscode.lm.registerTool('vb6ui_extractScreenSpec', new ExtractScreenSpecTool())
  );
}


VS Code exposes registerTool for registering LanguageModelTools.

7.5 Optional: Chat Participant (nice UX, not required)

A chat participant lets you provide a dedicated @yourParticipant in chat and orchestrate tool calls from there.

8) End-to-end execution flow (what happens when someone converts a VB form)
Happy path (recommended)

Developer selects Agent: “Angular UI Generator”

They provide:

.frm path (or drag file context)

target feature path (apps/<app>/src/app/features/<feature> or equivalent)

Agent calls tools in order:

#tool:extractScreenSpec

#tool:refineScreenSpec (apply split strategy + mapping rules)

#tool:generateAngularUi (configs + thin wrappers)

#tool:validateUiConfigs (schemas + forbidden patterns)

#tool:runAngularGates (lint/build)

#tool:writeMigrationReport (TODOs, unsupported controls, next steps)

This is exactly what custom agents + tool calling are meant to enable: consistent workflows with controlled tool access and handoffs.

If gates fail

The agent offers a handoff to “Fix & Stabilize”

Fixer makes minimal edits + re-runs gates

Gatekeeper confirms compliance + closes the loop

Handoffs are defined in agent frontmatter and appear as buttons after a response.

9) Model / quota strategy (how to avoid burning premium models)

VS Code supports switching models per chat; premium models may show a multiplier indicator.

Practical policy

Analyzer + Refiner: run on cheaper models (or no model, if deterministic parsing)

Generator: default model

Fixer: only escalate to premium after deterministic fixes fail and only for targeted diffs

Put this as a hard rule inside the Generator + Fixer agent instructions.

10) Cloud agent vs local agents (don’t mix these up)

Agents in VS Code are interactive and run with you in the editor.

Copilot coding agent is a cloud agent that runs remotely and produces PRs; it can’t access VS Code runtime context/tools the same way local agents do.

Use cloud agent only for well-scoped background tasks (e.g., “convert 20 forms overnight”) once your pipeline is stable and reproducible.

11) Reference templates you can drop in immediately
11.1 angular-ui-generator.agent.md (tight, tool-driven)

Use the draft you already asked for (it follows the supported frontmatter fields and #tool: syntax). Custom agent files support tools lists and handoffs.

11.2 vb6-angular-ui/SKILL.md (the real “playbook”)

Make sure your skill follows the required name/description frontmatter and lives under .github/skills.

12) What “done” looks like (acceptance criteria)
Repo setup

.github/agents/*.agent.md exists and agents appear in VS Code agent dropdown

.github/skills/vb6-angular-ui/SKILL.md exists and skills are enabled via chat.useAgentSkills

Always-on rules exist (copilot-instructions.md / .github/instructions/*)

Extension setup

Tools declared in package.json + registered via vscode.lm.registerTool

Tool schemas validate input and enforce deterministic behavior

Generator produces:

Parent component + child tab components

Config files for PageLayout/SharedTabGroup/FormBuilder/SharedMatTable

Migration report + TODO list

Gatekeeper runs validations + lint/build and returns pass/fail

13) Troubleshooting checklist

Agent not showing up: confirm VS Code ≥ 1.106 and file is under .github/agents with .agent.md extension.

Skill not loading: confirm chat.useAgentSkills enabled and skill exists under .github/skills/<skill>/SKILL.md with correct frontmatter.

Tool listed but not working: tool must be both contributed in package.json and registered in code; otherwise it won’t be available.

Tool ignored in agent: if the tool isn’t available in the current environment, VS Code ignores it.

14) What your extension dev should implement first (minimal viable pipeline)

extractScreenSpec(frm) → writes generated/<screenId>/screen.spec.json

generateAngularUi(spec, target) → creates configs + thin wrappers + folder structure

validateUiConfigs(target) → schema + forbidden pattern scan

runAngularGates() → lint/build

Wire these into Agent: Angular UI Generator via tool names

Once these are stable, add:

split strategy refinements

reuse extraction

bulk conversion command

cloud agent delegation (optional)

If you want, I’ll also paste full concrete files for all 5 agents (.agent.md each) and a tight skill directory skeleton (mapping docs + example golden screens + config contract stubs) so your team can copy/paste into the repo and start immediately.

yes go ahead
Thought for 8s

Below is a copy/paste-ready package: 5 full .agent.md files + a tight skill folder skeleton (with starter docs you can expand). Tool names are placeholders—keep them consistent with whatever your VS Code extension registers.

0) Drop-in folder structure
.github/
├─ agents/
│  ├─ vb6-ui-analyzer.agent.md
│  ├─ screen-spec-refiner.agent.md
│  ├─ angular-ui-generator.agent.md
│  ├─ ui-kit-gatekeeper.agent.md
│  └─ ui-fix-and-stabilize.agent.md
│
├─ skills/
│  └─ vb6-angular-ui/
│     ├─ SKILL.md
│     ├─ mapping/
│     │  ├─ vb-control-map.md
│     │  ├─ split-strategy.md
│     │  └─ rules.md
│     ├─ templates/
│     │  ├─ config-snippets.md
│     │  ├─ naming-rules.md
│     │  └─ report-template.md
│     ├─ contracts/
│     │  ├─ page-layout.contract.md
│     │  ├─ shared-tab-group.contract.md
│     │  ├─ form-builder.contract.md
│     │  └─ shared-mat-table.contract.md
│     └─ examples/
│        └─ golden-screens/
│           ├─ simple-form/
│           │  └─ README.md
│           ├─ tabbed-form/
│           │  └─ README.md
│           ├─ table-heavy/
│           │  └─ README.md
│           └─ mixed/
│              └─ README.md
│
├─ copilot-instructions.md
└─ instructions/
   ├─ angular-ui.instructions.md
   └─ forbidden-patterns.instructions.md

1) Always-on rules (recommended)
.github/copilot-instructions.md
# Global Copilot Instructions (VB6 → Angular UI Migration)

## Hard rules
- Generated Angular screens must be **config-driven** and use our shared primitives:
  - PageLayout/Container
  - SharedTabGroup
  - FormBuilder
  - SharedMatTable
- Do not generate raw Angular Material components (no mat-tab-group/mat-table as the primary implementation).
- Screen components must be thin wrappers:
  - wiring + handler stubs only
  - no custom reactive form templates
  - no bespoke table logic
- Prefer deterministic tool-calling workflow:
  - Parse → ScreenSpec → Generate configs → Generate wrappers → Validate → Gates → Report

## Output hygiene
- Keep diffs minimal.
- Keep naming stable and predictable.
- Any unsupported VB control must be listed in a migration report with TODO actions.

.github/instructions/angular-ui.instructions.md
---
applyTo: "**/*.ts, **/*.html, **/*.scss"
---

# Angular UI standards

- Use Angular 21 patterns (standalone/components if that’s your repo standard).
- Use our BaseComponent/BasePageComponent and shared services if applicable.
- Prefer inputs/outputs for parent-child component interaction (tabs/sections).
- Keep templates minimal: shared components only with configs.

.github/instructions/forbidden-patterns.instructions.md
---
applyTo: "**/*"
---

# Forbidden patterns

- Do not generate screens that directly implement:
  - mat-table (as the main table)
  - mat-tab-group (as the main tab system)
  - hand-crafted form markup for data entry (must use FormBuilder)
- Do not introduce new shared components.
- Do not modify shared libs unless explicitly requested.

2) Custom Agents (5 full files)

Put these under .github/agents/.

2.1 vb6-ui-analyzer.agent.md
---
name: VB6 UI Analyzer
description: Parse VB6 .frm and produce an initial ScreenSpec IR (screen.spec.json) + parse diagnostics. Read-only, deterministic.
target: vscode
tools:
  - extractScreenSpec
  - readFile
  - findInFiles
  - usages
  - terminal
handoffs:
  - label: Refine ScreenSpec
    agent: screen-spec-refiner
    prompt: "Refine the ScreenSpec: normalize naming, apply split strategy, improve mapping clarity, and mark unsupported controls."
    send: false
---

# VB6 UI Analyzer — Rules

## What you do
- Convert VB6 `.frm` (and optional `.bas/.cls` scan) into:
  - `generated/<screenId>/screen.spec.json`
  - Optional debug output: parse-model, control tree, event list

## What you do NOT do
- Do not generate Angular code.
- Do not decide UI patterns beyond what mapping rules prescribe.
- Do not modify application source files.

## Workflow
1) Gather inputs:
   - frmPath (required)
   - optional: related bas/cls paths
2) Call `#tool:extractScreenSpec` with frmPath.
3) Return:
   - screenId, title, detected tabs/frames/grids
   - list of events discovered
   - list of unsupported/unknown controls
4) Offer handoff to ScreenSpec Refiner.

2.2 screen-spec-refiner.agent.md
---
name: ScreenSpec Refiner
description: Normalize and enrich ScreenSpec for Angular UI generation (naming, component split, mapping consistency). Produces a generation-ready spec.
target: vscode
tools:
  - readFile
  - writeFile
  - refineScreenSpec
  - validateUiConfigs
  - findInFiles
handoffs:
  - label: Generate Angular UI
    agent: angular-ui-generator
    prompt: "Generate Angular UI from the refined ScreenSpec using shared primitives. Create parent + child tab components + config files."
    send: false
---

# ScreenSpec Refiner — Rules

## Objective
Turn an “initial” ScreenSpec into a “generation-ready” ScreenSpec.

## Hard rules
- Apply deterministic naming rules (stable camelCase, predictable ids).
- Apply split strategy:
  - each tab becomes a child component by default
- Ensure mapping aligns with shared primitives:
  - tabs → SharedTabGroup
  - forms → FormBuilder
  - grids → SharedMatTable
  - layout → PageLayout/Container
- Unsupported VB controls must be captured in `unsupported[]` and not silently dropped.

## Workflow
1) Input:
   - screenSpecPath (required)
2) Call `#tool:refineScreenSpec`:
   - apply naming normalization
   - apply split strategy
   - enforce mapping rules
3) Optionally call `#tool:validateUiConfigs` in “spec-only” mode (if supported).
4) Save updated spec back to the same location (or a `screen.refined.spec.json`).
5) Summarize what changed:
   - renamed ids
   - created component boundaries
   - unsupported list
6) Offer handoff to Angular UI Generator.

2.3 angular-ui-generator.agent.md
---
name: Angular UI Generator
description: Generate Angular 21 screens from ScreenSpec using shared primitives (PageLayout, SharedTabGroup, FormBuilder, SharedMatTable). Produces config-driven UI + thin wrappers.
target: vscode
tools:
  - readFile
  - generateAngularUi
  - applyWorkspaceEdits
  - validateUiConfigs
  - runAngularGates
  - writeMigrationReport
handoffs:
  - label: Run Gatekeeper Review
    agent: ui-kit-gatekeeper
    prompt: "Validate compliance (shared primitives only), run gates, and confirm the screen is production-ready. If failures exist, propose minimal fixes."
    send: false
---

# Angular UI Generator — Rules

## Hard guardrails
1) Shared primitives only:
   - PageLayout/Container
   - SharedTabGroup
   - FormBuilder
   - SharedMatTable
2) Config-driven UI:
   - Fields via FormBuilder config
   - Tables via SharedMatTable config
   - Tabs via SharedTabGroup config
   - Layout via PageLayout config
3) Thin wrappers:
   - minimal TS + minimal HTML
   - handler stubs allowed
4) No raw Angular Material tabs/tables/forms as main implementation.

## Inputs required
- screenSpecPath (preferred)
- targetFeaturePath (required)
Optional:
- targetRoutingFile / nav config path (if your tool supports it)
- costProfile (economy|balanced|premium) — enforced by tool router

## Workflow
1) Read ScreenSpec.
2) Call `#tool:generateAngularUi` (spec + target path).
3) Apply edits:
   - either tool writes directly
   - or call `#tool:applyWorkspaceEdits` if your generator returns a plan
4) Call `#tool:validateUiConfigs`:
   - schema validation
   - forbidden patterns scan
5) Call `#tool:runAngularGates` (lint/build).
6) Call `#tool:writeMigrationReport`:
   - generated files list
   - TODOs / unsupported controls
   - gate results
7) Offer handoff to Gatekeeper.

2.4 ui-kit-gatekeeper.agent.md
---
name: UI Kit Gatekeeper
description: Enforce shared UI kit compliance and quality gates (schema validation + forbidden patterns + lint/build). Read-only unless explicitly fixing.
target: vscode
tools:
  - validateUiConfigs
  - runAngularGates
  - readFile
  - findInFiles
handoffs:
  - label: Fix & Stabilize
    agent: ui-fix-and-stabilize
    prompt: "Fix lint/build failures with minimal diffs, keep shared-kit compliance, and rerun gates until pass."
    send: false
---

# UI Kit Gatekeeper — Rules

## What you validate
- Config schema validity (PageLayout/TabGroup/FormBuilder/MatTable configs)
- Forbidden patterns scan:
  - no mat-tab-group / mat-table as primary
  - no custom reactive form templates
- Quality gates:
  - lint (required)
  - build (recommended)
  - tests (optional)

## Output
- PASS: confirm compliance + list what was checked
- FAIL: list violations with file paths and actionable fixes

## Workflow
1) Call `#tool:validateUiConfigs` on the target feature path or screen folder.
2) Call `#tool:runAngularGates`.
3) Summarize results:
   - compliance violations (if any)
   - gate failures (if any)
4) If failures exist, offer handoff to Fix & Stabilize.

2.5 ui-fix-and-stabilize.agent.md
---
name: Fix & Stabilize
description: Apply minimal diffs to fix lint/build failures while preserving shared-kit patterns. No refactors. No pattern changes.
target: vscode
tools:
  - patchAngularUi
  - validateUiConfigs
  - runAngularGates
  - readFile
  - writeFile
  - applyWorkspaceEdits
---

# Fix & Stabilize — Rules

## Hard guardrails
- Make minimal diffs only.
- Do not refactor architecture or introduce new patterns.
- Do not replace shared primitives with raw Material.
- Do not change shared libs unless explicitly asked.

## Workflow
1) Input:
   - targetScreenPath (screen folder)
   - gate error logs (from previous run) if available
2) Call `#tool:patchAngularUi` with the errors + target path.
3) Call `#tool:validateUiConfigs` again.
4) Call `#tool:runAngularGates` again.
5) Repeat once if needed; if still failing, stop and return a precise “manual TODO list” with file/line guidance.

3) Skill package (vb6-angular-ui)

Put these under .github/skills/vb6-angular-ui/.

3.1 SKILL.md
---
name: vb6-angular-ui
description: Playbook for converting VB6 .frm UIs into Angular 21 config-driven screens using PageLayout, SharedTabGroup, FormBuilder, and SharedMatTable. Includes mapping rules, split strategy, naming rules, and golden screen patterns.
---

# VB6 → Angular UI Skill (Shared UI Kit)

## Purpose
Teach how to convert VB6 forms into Angular UI using our shared primitives:
- PageLayout/Container
- SharedTabGroup
- FormBuilder
- SharedMatTable

This skill is used by agents during:
- ScreenSpec refinement
- Angular UI generation
- Compliance checking

## Hard rules (must follow)
- Config-driven UI only (FormBuilder/Table/TabGroup/Layout configs)
- Thin wrapper components only
- No raw Material tabs/tables/forms as primary implementation
- Golden screens define the canonical patterns

## Where to look
- Mapping: `mapping/vb-control-map.md`, `mapping/rules.md`
- Split strategy: `mapping/split-strategy.md`
- Naming: `templates/naming-rules.md`
- Starter config snippets: `templates/config-snippets.md`
- Contracts (high-level): `contracts/*.contract.md`
- Golden patterns: `examples/golden-screens/*`

## Output expectations
A generated screen should have:
- Parent screen component + template
- Child components (one per tab by default)
- `<screenId>.config.ts` with PageLayout + TabGroup + FormBuilder + MatTable configs
- Migration report listing TODOs + unsupported mappings

3.2 Mapping docs
mapping/vb-control-map.md
# VB6 Control → Shared UI Primitive Map

Use this mapping deterministically. Do not invent new primitives.

| VB6 Control / Pattern | Detect Hint | Angular Shared Primitive | Notes |
|---|---|---|---|
| SSTab / TabStrip | multiple tab pages | SharedTabGroup | each tab becomes a child component by default |
| Frame / grouping | VB Frame, PictureBox grouping | PageLayout section/card | preserve heading/caption |
| TextBox | plain input | FormBuilder.Text | use maxLength if present |
| Masked edit | mask formatting | FormBuilder.MaskedText | preserve mask pattern |
| ComboBox | dropdown | FormBuilder.Select | lookup-backed if Tag/DataSource suggests |
| CheckBox | boolean | FormBuilder.Checkbox | |
| OptionButton | radio | FormBuilder.RadioGroup | |
| MSFlexGrid / ListView | grid/rows/columns | SharedMatTable | columns inferred; actions from buttons/events |
| CommandButton | action | PageLayout actions | Save/Cancel etc. map to header actions |

## Unsupported controls
If a VB6 control cannot be mapped:
- Add it to `unsupported[]` in ScreenSpec
- Generate TODO placeholder in the screen/child component
- Record in migration report

mapping/split-strategy.md
# Split Strategy (VB6 single .frm → Angular components)

## Default
- Parent screen component:
  - PageLayout + SharedTabGroup (if tabs exist)
  - top-level actions (Save/Cancel)
  - orchestration (load/save) per BaseComponent pattern

- Child components:
  - 1 per tab (Borrower/Loan/Booking)
  - Each child renders shared primitives via config

## Threshold-based splitting (optional)
Split a tab into section components if:
- > 15 fields in one section
- multiple independent sections with separate logic
- reuse is expected across screens

## Reuse rule (optional)
If a section appears identical across screens:
- mark as reusable in ScreenSpec
- generate into a shared feature library instead of the screen folder

mapping/rules.md
# Shared UI Kit Rules

## Required patterns
- Tabs => SharedTabGroup config
- Forms => FormBuilder config
- Tables => SharedMatTable config
- Layout => PageLayout config

## Forbidden patterns
- No mat-tab-group/mat-table as primary
- No bespoke form markup for data entry
- No custom table logic in screen components

## Event handling
- Parent owns cross-tab rules
- Child emits events (changed/validity/action) to parent
- Parent decides save orchestration

3.3 Templates
templates/naming-rules.md
# Naming Rules

## Screen identifiers
- screenId: PascalCase in spec, kebab-case or folder-case in file paths (follow repo standard)
- folder: `<screenId>/` (use normalized lowercase or kebab-case if your repo standard)

## Files
- parent component: `<screenId>.component.ts/html/scss`
- config: `<screenId>.config.ts`
- child tab: `<screenId>-<tabId>.component.*` OR `<tabId>.component.*` (pick one convention and stick to it)

## Control name normalization
- VB: txtBorrowerName → borrowerName
- VB: cboStatus → status
- Preserve original VB control name in a comment if needed:
  `// VB: txtBorrowerName`

templates/config-snippets.md
# Config Snippets (starter shapes)

## PageLayout (example)
```ts
export const layoutConfig = {
  title: 'Borrower',
  container: 'FullWidth',
  headerActions: ['Save', 'Cancel'],
  sections: [
    { id: 'borrowerInfo', title: 'Borrower Info', layout: 'TwoColumn' }
  ]
} as const;

SharedTabGroup (example)
export const tabGroupConfig = {
  strategy: 'lazy',
  tabs: [
    { id: 'borrower', label: 'Borrower', component: 'BorrowerTabComponent' },
    { id: 'loan', label: 'Loan', component: 'LoanTabComponent' }
  ]
} as const;

FormBuilder (example)
export const borrowerFormConfig = {
  formKey: 'borrowerForm',
  fields: [
    { name: 'firstName', type: 'Text', label: 'First Name', validators: ['required'] },
    { name: 'ssn', type: 'MaskedText', label: 'SSN', mask: '###-##-####' }
  ]
} as const;

SharedMatTable (example)
export const employmentTableConfig = {
  dataKey: 'employmentRows',
  idKey: 'id',
  columns: [
    { key: 'employer', header: 'Employer', cell: 'text' },
    { key: 'startDate', header: 'Start Date', cell: 'date' }
  ],
  rowActions: ['Add', 'Edit', 'Delete']
} as const;


#### `templates/report-template.md`
```md
# Migration Report Template

## Screen
- screenId:
- source frm:
- target path:

## Generated files
- ...

## Mapping summary
- Tabs:
- Forms:
- Tables:

## Unsupported / TODO
- ...

## Gates
- lint:
- build:
- test (optional):

3.4 Contracts (high-level placeholders)

Replace these with real contracts or link to your ui-kit-catalog interfaces/schemas.

contracts/page-layout.contract.md
# PageLayout Contract (high level)

## Required
- title
- container type
- header actions
- sections/cards

## Notes
- Layout must be declarative and driven by config.

contracts/shared-tab-group.contract.md
# SharedTabGroup Contract (high level)

## Required
- strategy: lazy/eager
- tabs: [{ id, label, componentRef/configRef }]

## Notes
- Default: each tab maps to a child component.

contracts/form-builder.contract.md
# FormBuilder Contract (high level)

## Required
- formKey
- fields[] with:
  - name
  - type
  - label
  - validators (optional)
  - mask (optional)
  - dto binding key (if applicable)

## Notes
- No bespoke form templates in screen components.

contracts/shared-mat-table.contract.md
# SharedMatTable Contract (high level)

## Required
- dataKey
- idKey
- columns[] with cell type
- row actions (optional)

## Notes
- Avoid custom table logic outside config unless a known exception.

3.5 Golden screen READMEs (placeholders)
examples/golden-screens/simple-form/README.md
# Golden Screen: Simple Form

Purpose: baseline for FormBuilder-only pages.
Includes:
- layoutConfig + formConfig
- thin wrapper component/template
Rules:
- no raw material form markup
- config-driven fields only

examples/golden-screens/tabbed-form/README.md
# Golden Screen: Tabbed Form

Purpose: SharedTabGroup + multiple child tab components.
Includes:
- parent page + tabGroupConfig
- one child component per tab
- each tab uses FormBuilder configs

examples/golden-screens/table-heavy/README.md
# Golden Screen: Table Heavy

Purpose: SharedMatTable patterns (readonly + row actions).
Includes:
- tableConfig variants
- optional row editor patterns (dialog or inline) per your shared kit

examples/golden-screens/mixed/README.md
# Golden Screen: Mixed

Purpose: Tabs + FormBuilder + MatTable + dialogs.
Includes:
- parent orchestrating events across tabs
- child components emitting events
- config-driven UI everywhere

4) VS Code settings note (skills)

To use skills, devs typically need to enable:

chat.useAgentSkills (preview feature; depends on VS Code/Copilot setup)

(Your extension can work even without skills; skills just make agents consistent.)

5) What your extension must expose as tools (minimum)

Your agents assume these tools exist:

extractScreenSpec(frmPath)

refineScreenSpec(screenSpecPath, options)

generateAngularUi(screenSpecPath, targetFeaturePath)

validateUiConfigs(targetPathOrSpecPath)

runAngularGates(appOrWorkspace)

patchAngularUi(targetPath, errors)

writeMigrationReport(screenId|paths, results)

plus basic readFile/writeFile/findInFiles equivalents (if not built-in)

If your tool names differ, rename them consistently in all agent files.

If you paste your actual tool IDs / toolReferenceName values from the extension package.json, I’ll rewrite the agent files to match them exactly (so nothing silently fails at runtime).
