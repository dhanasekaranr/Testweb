## Project Structure

```
/src
  /Shared.LookupService
    Shared.LookupService.csproj
    /Models
      LookupDefinition.cs
      LookupItem.cs
    /Stores
      ILookupDefinitionStore.cs
      DbLookupDefinitionStore.cs
      JsonLookupDefinitionStore.cs
    /Providers
      ILookupProvider.cs
      TableLookupProvider.cs
      HandlerLookupProvider.cs
    /Factory
      LookupProviderFactory.cs
    /Services
      LookupDataService.cs
      CachingLookupDataService.cs
    /Extensions
      ServiceCollectionExtensions.cs

  /LookupApi.Common
    LookupApi.Common.csproj
    Program.cs
    appsettings.json
    /Data
      MockDbContext.cs
    /Models
      LookupDefinitionEntity.cs
      LoanStatusCategoryEntity.cs
      LoanStatusEntity.cs
    /Controllers
      LookupController.cs

  /FundingModuleApi
    FundingModuleApi.csproj
    Program.cs
    appsettings.json
    /Controllers
      FundingController.cs
```

---

# Shared.LookupService (Class Library)

### Shared.LookupService.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.0" />
    <PackageReference Include="Dapper" Version="2.0.123" />
  </ItemGroup>
</Project>
```

### Models/LookupDefinition.cs

```csharp
namespace Shared.LookupService.Models;

/// <summary>
/// Defines a lookup and its source configuration.
/// Only one source property should be set based on <see cref="LookupSourceType"/>.
/// </summary>
public class LookupDefinition
{
    /// <summary>Logical key for the lookup.</summary>
    public string Key { get; set; } = null!;

    /// <summary>Specifies which lookup source to use.</summary>
    public LookupSourceType SourceType { get; set; }

    /// <summary>Table-based lookup: name of the DB table.</summary>
    public string? TableName { get; set; }

    /// <summary>SQL-based lookup: raw SQL query.</summary>
    public string? Sql { get; set; }

    /// <summary>Entity-based lookup: fully qualified entity type.</summary>
    public string? EntityType { get; set; }

    /// <summary>Handler-based lookup: fully qualified handler type.</summary>
    public string? HandlerType { get; set; }

    /// <summary>List of filterable column names (for WHERE clauses).</summary>
    public string[] FilterColumns { get; set; } = Array.Empty<string>();

    /// <summary>Optional ORDER BY clause column.</summary>
    public string? SortBy { get; set; }

    /// <summary>Column for the lookup code/value.</summary>
    public string? CodeColumn { get; set; }

    /// <summary>Column for the lookup description/text.</summary>
    public string? DescColumn { get; set; }

    /// <summary>Additional columns to include in the result set.</summary>
    public string[] AdditionalColumns { get; set; } = Array.Empty<string>();
}

/// <summary>Defines the type of lookup source to use.</summary>
public enum LookupSourceType
{
    Table,
    Sql,
    Entity,
    Handler
}
```

csharp
namespace Shared.LookupService.Models;

public class LookupDefinition
{
public string   Key               { get; set; } = null!;
public string?  TableName         { get; set; }
public string?  Sql               { get; set; }
public string?  EntityType        { get; set; }
public string?  HandlerType       { get; set; }
public string\[] FilterColumns     { get; set; } = Array.Empty<string>();
public string?  SortBy            { get; set; }
public string?  CodeColumn        { get; set; }
public string?  DescColumn        { get; set; }
public string\[] AdditionalColumns { get; set; } = Array.Empty<string>();
}

````

### Models/LookupItem.cs
```csharp
namespace Shared.LookupService.Models;

public record LookupItem(
    string Code,
    string Description,
    IDictionary<string, object>? AdditionalData = null
);
````

### Stores/ILookupDefinitionStore.cs

```csharp
using Shared.LookupService.Models;

namespace Shared.LookupService.Stores;

public interface ILookupDefinitionStore
{
    Task<IReadOnlyList<LookupDefinition>> GetAllAsync();
    Task RefreshAsync(string key);
    Task RefreshAllAsync();
}
```

### Stores/DbLookupDefinitionStore.cs

```csharp
using Microsoft.EntityFrameworkCore;
using Shared.LookupService.Models;
using LookupApi.Common.Data;
using System.Text.Json;

namespace Shared.LookupService.Stores;

public class DbLookupDefinitionStore : ILookupDefinitionStore
{
    private readonly MockDbContext _db;
    public DbLookupDefinitionStore(MockDbContext db) => _db = db;

    public async Task<IReadOnlyList<LookupDefinition>> GetAllAsync()
    {
        var rows = await _db.LookupDefinitions.AsNoTracking().ToListAsync();
        return rows.Select(r => new LookupDefinition
        {
            Key               = r.Key,
            TableName         = r.TableName,
            Sql               = r.Sql,
            EntityType        = r.EntityType,
            HandlerType       = r.HandlerType,
            FilterColumns     = JsonSerializer.Deserialize<string[]>(r.FilterColumns) ?? Array.Empty<string>(),
            SortBy            = r.SortBy,
            CodeColumn        = r.CodeColumn,
            DescColumn        = r.DescColumn,
            AdditionalColumns = JsonSerializer.Deserialize<string[]>(r.AdditionalColumns) ?? Array.Empty<string>()
        }).ToList();
    }

    public Task RefreshAsync(string key)
    {
        // eviction handled in decorator
        return Task.CompletedTask;
    }

    public Task RefreshAllAsync() => Task.CompletedTask;
}
```

### Stores/JsonLookupDefinitionStore.cs

```csharp
using Microsoft.Extensions.Options;
using Shared.LookupService.Models;

namespace Shared.LookupService.Stores;

public class JsonLookupDefinitionStore : ILookupDefinitionStore
{
    private readonly IOptionsMonitor<List<LookupDefinition>> _monitor;
    public JsonLookupDefinitionStore(IOptionsMonitor<List<LookupDefinition>> monitor)
        => _monitor = monitor;

    public Task<IReadOnlyList<LookupDefinition>> GetAllAsync()
        => Task.FromResult((IReadOnlyList<LookupDefinition>)_monitor.CurrentValue);

    public Task RefreshAsync(string key)    => Task.CompletedTask;
    public Task RefreshAllAsync()           => Task.CompletedTask;
}
```

### Providers/ILookupProvider.cs

```csharp
using Shared.LookupService.Models;

namespace Shared.LookupService.Providers;

public interface ILookupProvider
{
    Task<IEnumerable<LookupItem>> GetAsync(
        LookupDefinition def,
        IDictionary<string, object>? filters = null);
}
```

### Providers/TableLookupProvider.cs

```csharp
using Dapper;
using Shared.LookupService.Models;
using System.Data;
using System.Text;

namespace Shared.LookupService.Providers;

public class TableLookupProvider : ILookupProvider
{
    private readonly IDbConnection _db;
    public TableLookupProvider(IDbConnection db) => _db = db;

    public async Task<IEnumerable<LookupItem>> GetAsync(
        LookupDefinition def,
        IDictionary<string, object>? filters = null)
    {
        if (string.IsNullOrWhiteSpace(def.TableName))
            throw new ArgumentException("TableName required");

        var codeCol = def.CodeColumn ?? "Code";
        var descCol = def.DescColumn ?? "Description";

        var selectCols = new List<string>
        {
            $"{codeCol} AS Code",
            $"{descCol} AS Description"
        };
        if (def.AdditionalColumns.Any())
            selectCols.AddRange(def.AdditionalColumns.Select(ac => $"{ac} AS {ac}"));

        var sql = new StringBuilder(
            $"SELECT {string.Join(", ", selectCols)} FROM {def.TableName}");

        if (filters?.Any() == true)
        {
            var clauses = def.FilterColumns
                             .Where(c => filters.ContainsKey(c))
                             .Select(c => $"{c}=@{c}");
            sql.Append(" WHERE ").Append(string.Join(" AND ", clauses));
        }
        if (!string.IsNullOrEmpty(def.SortBy))
            sql.Append($" ORDER BY {def.SortBy}");

        var rows = await _db.QueryAsync<dynamic>(sql.ToString(), filters);
        var results = new List<LookupItem>();
        foreach (IDictionary<string, object> row in rows)
        {
            var code = row["Code"].ToString()!;
            var desc = row["Description"].ToString()!;
            var additional = def.AdditionalColumns.ToDictionary(
                ac => ac,
                ac => row.ContainsKey(ac) ? row[ac]! : null
            );
            results.Add(new LookupItem(code, desc, additional));
        }
        return results;
    }
}
```

### Providers/HandlerLookupProvider.cs

```csharp
using Shared.LookupService.Models;
using Shared.LookupService.Stores;

namespace Shared.LookupService.Providers;

public class HandlerLookupProvider : ILookupProvider
{
    private readonly IServiceProvider _sp;
    public HandlerLookupProvider(IServiceProvider sp) => _sp = sp;

    public async Task<IEnumerable<LookupItem>> GetAsync(
        LookupDefinition def,
        IDictionary<string, object>? filters = null)
    {
        if (string.IsNullOrWhiteSpace(def.HandlerType))
            throw new ArgumentException("HandlerType required");

        var handlerType = Type.GetType(def.HandlerType)
                           ?? throw new InvalidOperationException($"Cannot load {def.HandlerType}");
        var handler = (ILookupHandler)_sp.GetRequiredService(handlerType);
        return await handler.HandleAsync(def, filters);
    }
}
```

### Example: Custom Handler for Product Types

Add a handler to fetch product types dynamically based on `AppId`.

#### Providers/ProductTypeLookupHandler.cs

```csharp
using Dapper;
using Shared.LookupService.Models;
using System.Data;

namespace Shared.LookupService.Providers;

public class ProductTypeLookupHandler : ILookupHandler
{
    private readonly IDbConnection _db;
    public ProductTypeLookupHandler(IDbConnection db) => _db = db;

    public async Task<IEnumerable<LookupItem>> HandleAsync(
        LookupDefinition def,
        IDictionary<string, object>? filters = null)
    {
        if (filters == null || !filters.TryGetValue("AppId", out var appIdObj))
            throw new ArgumentException("Filter 'AppId' is required for ProductTypes lookup.");
        var appId = appIdObj.ToString();

        // Example branching logic based on AppId
        string sql;
        if (appId == "1")
        {
            // Join table A and B for app 1
            sql = @"SELECT pt.TypeCode AS Code, pt.TypeName AS Description, pt.IsActive
                      FROM ProductTypes pt
                      JOIN App1Settings a1 ON pt.TypeCode = a1.TypeCode
                      WHERE a1.IsEnabled = 1";
        }
        else if (appId == "2")
        {
            // Hardcoded list for app 2
            return new[] {
                new LookupItem("X", "Type X"),
                new LookupItem("Y", "Type Y")
            };
        }
        else
        {
            // Default product types
            sql = "SELECT TypeCode AS Code, TypeName AS Description FROM DefaultProductTypes";
        }

        var rows = await _db.QueryAsync<(string Code, string Description)>(sql);
        return rows.Select(r => new LookupItem(r.Code, r.Description));
    }
}
```

#### Configuration Example (JSON)

````json
[
  {
    "Key": "ProductTypes",
    "SourceType": "Handler",
    "HandlerType": "Shared.LookupService.Providers.ProductTypeLookupHandler, Shared.LookupService",
    "FilterColumns": [ "AppId" ]
  }
]
```csharp
using Shared.LookupService.Models;
using Shared.LookupService.Stores;

namespace Shared.LookupService.Providers;

public class HandlerLookupProvider : ILookupProvider
{
    private readonly IServiceProvider _sp;
    public HandlerLookupProvider(IServiceProvider sp) => _sp = sp;

    public async Task<IEnumerable<LookupItem>> GetAsync(
        LookupDefinition def,
        IDictionary<string, object>? filters = null)
    {
        if (string.IsNullOrWhiteSpace(def.HandlerType))
            throw new ArgumentException("HandlerType required");

        var handlerType = Type.GetType(def.HandlerType)
                           ?? throw new InvalidOperationException($"Cannot load {def.HandlerType}");
        var handler = (ILookupHandler)_sp.GetRequiredService(handlerType);
        return await handler.HandleAsync(def, filters);
    }
}
````

### Factory/LookupProviderFactory.cs

```csharp
using Shared.LookupService.Models;
using Shared.LookupService.Providers;

namespace Shared.LookupService.Factory;

public class LookupProviderFactory
{
    private readonly IEnumerable<ILookupProvider> _providers;
    public LookupProviderFactory(IEnumerable<ILookupProvider> providers)
        => _providers = providers;

    public ILookupProvider Get(LookupDefinition def)
    {
        if (!string.IsNullOrWhiteSpace(def.HandlerType)) return _providers.OfType<HandlerLookupProvider>().First();
        return _providers.OfType<TableLookupProvider>().First();
    }
}
```

### Services/LookupDataService.cs

```csharp
using Shared.LookupService.Models;
using Shared.LookupService.Stores;
using Shared.LookupService.Factory;

namespace Shared.LookupService.Services;

public class LookupDataService : ILookupDataService
{
    private readonly IReadOnlyDictionary<string, LookupDefinition> _defs;
    private readonly LookupProviderFactory _factory;

    public LookupDataService(
        ILookupDefinitionStore defStore,
        LookupProviderFactory factory)
    {
        _defs = defStore.GetAllAsync()
                       .GetAwaiter().GetResult()
                       .ToDictionary(d => d.Key, StringComparer.OrdinalIgnoreCase);
        _factory = factory;
    }

    public Task<IEnumerable<LookupItem>> GetAsync(
        string key,
        IDictionary<string, object>? filters = null)
    {
        if (!_defs.TryGetValue(key, out var def))
            throw new KeyNotFoundException($"No lookup defined for '{key}'");
        var provider = _factory.Get(def);
        return provider.GetAsync(def, filters);
    }
}
```

### Services/CachingLookupDataService.cs

```csharp
using Microsoft.Extensions.Caching.Memory;
using Shared.LookupService.Models;

namespace Shared.LookupService.Services;

public class CachingLookupDataService : ILookupDataService
{
    private readonly LookupDataService _inner;
    private readonly IMemoryCache _cache;
    private readonly TimeSpan _ttl = TimeSpan.FromMinutes(10);

    public CachingLookupDataService(
        LookupDataService inner,
        IMemoryCache cache)
    {
        _inner = inner;
        _cache = cache;
    }

    public Task<IEnumerable<LookupItem>> GetAsync(
        string key,
        IDictionary<string, object>? filters = null)
    {
        var filterKey = filters == null
            ? string.Empty
            : string.Join(";", filters.OrderBy(kv => kv.Key).Select(kv => $"{kv.Key}={kv.Value}"));
        var cacheKey = $"LookupRes:{key}:{filterKey}";
        return _cache.GetOrCreateAsync(cacheKey, entry =>
        {
            entry.SlidingExpiration = _ttl;
            return _inner.GetAsync(key, filters)!;
        })!;
    }
}
```

### Extensions/ServiceCollectionExtensions.cs

```csharp
using Shared.LookupService.Stores;
using Shared.LookupService.Providers;
using Shared.LookupService.Factory;
using Shared.LookupService.Services;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Microsoft.EntityFrameworkCore;
using LookupApi.Common.Data;

namespace Shared.LookupService.Extensions;

public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddLookupDefinitions(
        this IServiceCollection services,
        IConfiguration config,
        string source) // "Json" or "Db"
    {
        services.AddMemoryCache();
        services.AddTransient<IDbConnection>(_ => new SqlConnection(config.GetConnectionString("Default")));
        services.AddSingleton<TableLookupProvider>();
        services.AddSingleton<ILookupProvider, TableLookupProvider>();
        services.AddSingleton<HandlerLookupProvider>();
        services.AddSingleton<ILookupProvider, HandlerLookupProvider>();
        services.AddSingleton<LookupProviderFactory>();
        services.AddSingleton<LookupDataService>();
        services.AddScoped<CachingLookupDataService>();
        services.AddScoped<ILookupDataService>(sp => sp.GetRequiredService<CachingLookupDataService>());

        if (source == "Json")
        {
            services.Configure<List<LookupDefinition>>(config.GetSection("LookupDataSettings"));
            services.AddSingleton<ILookupDefinitionStore, JsonLookupDefinitionStore>();
        }
        else if (source == "Db")
        {
            services.AddDbContext<MockDbContext>(opts => opts.UseInMemoryDatabase("LookupDb"));
            services.AddScoped<ILookupDefinitionStore, DbLookupDefinitionStore>();
        }

        return services;
    }
}
```

---

# LookupApi.Common (Mock DB-backed API)

### LookupApi.Common.csproj

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">...
```

### appsettings.json

```json
{ "ConnectionStrings":{"Default":"InMemoryDb"}, ... }
```

### Data/MockDbContext.cs

````csharp
using Microsoft.EntityFrameworkCore;
using LookupApi.Common.Models;
using System.Text.Json;

namespace LookupApi.Common.Data;

public class MockDbContext : DbContext
{
    public MockDbContext(DbContextOptions<MockDbContext> options)
        : base(options)
    {
    }

    public DbSet<LookupDefinitionEntity> LookupDefinitions { get; set; }
    public DbSet<LoanStatusCategoryEntity> LoanStatusCategories { get; set; }
    public DbSet<LoanStatusEntity> LoanStatuses { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // LookupDefinitions Table
        modelBuilder.Entity<LookupDefinitionEntity>(entity =>
        {
            entity.HasKey(e => e.Key);
            entity.Property(e => e.Key).HasMaxLength(100).IsRequired();
            entity.Property(e => e.TableName).HasMaxLength(100);
            entity.Property(e => e.Sql);
            entity.Property(e => e.EntityType).HasMaxLength(200);
            entity.Property(e => e.HandlerType).HasMaxLength(200);
            entity.Property(e => e.FilterColumns);
            entity.Property(e => e.SortBy).HasMaxLength(100);
            entity.Property(e => e.CodeColumn).HasMaxLength(100);
            entity.Property(e => e.DescColumn).HasMaxLength(100);
            entity.Property(e => e.AdditionalColumns);

            // Seed definitions
            entity.HasData(
                new LookupDefinitionEntity
                {
                    Key = "Countries",
                    TableName = "RefCountries",
                    FilterColumns = JsonSerializer.Serialize(new[] { "IsActive" }),
                    SortBy = "CountryName",
                    CodeColumn = "CountryCode",
                    DescColumn = "CountryName",
                    AdditionalColumns = JsonSerializer.Serialize(Array.Empty<string>())
                },
                new LookupDefinitionEntity
                {
                    Key = "ComplexRates",
                    HandlerType = "MyApp.Lookups.MyComplexLookupHandler, MyApp"
                },
                new LookupDefinitionEntity
                {
                    Key = "LoanStatusCategory",
                    TableName = "LoanStatusCategories",
                    SortBy = "Name",
                    CodeColumn = "Id",
                    DescColumn = "Name",
                    AdditionalColumns = JsonSerializer.Serialize(Array.Empty<string>())
                },
                new LookupDefinitionEntity
                {
                    Key = "LoanStatuses",
                    TableName = "LoanStatuses",
                    FilterColumns = JsonSerializer.Serialize(new[] { "LoanStatusCategoryId" }),
                    SortBy = "Description",
                    CodeColumn = "Id",
                    DescColumn = "Description",
                    AdditionalColumns = JsonSerializer.Serialize(Array.Empty<string>())
                }
            );
        });

        // LoanStatusCategory Table
        modelBuilder.Entity<LoanStatusCategoryEntity>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Name).HasMaxLength(100).IsRequired();

            entity.HasData(
                new LoanStatusCategoryEntity { Id = 1, Name = "Application" },
                new LoanStatusCategoryEntity { Id = 2, Name = "Approval" }
            );
        });

        // LoanStatus Table
        modelBuilder.Entity<LoanStatusEntity>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Description).HasMaxLength(200).IsRequired();
            entity.HasOne(e => e.Category)
                  .WithMany(c => c.LoanStatuses)
                  .HasForeignKey(e => e.LoanStatusCategoryId);

            entity.HasData(
                new LoanStatusEntity { Id = 1, Description = "Submitted", LoanStatusCategoryId = 1 },
                new LoanStatusEntity { Id = 2, Description = "In Review", LoanStatusCategoryId = 1 },
                new LoanStatusEntity { Id = 3, Description = "Approved", LoanStatusCategoryId = 2 },
                new LoanStatusEntity { Id = 4, Description = "Funded", LoanStatusCategoryId = 2 }
            );
        });
    }
}
```csharp
using Microsoft.EntityFrameworkCore;
using LookupApi.Common.Models;
using System.Text.Json;

namespace LookupApi.Common.Data;

public class MockDbContext : DbContext { ... }
````

### Models/LookupDefinitionEntity.cs

```csharp
namespace LookupApi.Common.Models;

public class LookupDefinitionEntity
{
    public string Key { get; set; } = null!;
    public string? TableName { get; set; }
    public string? Sql { get; set; }
    public string? EntityType { get; set; }
    public string? HandlerType { get; set; }
    public string FilterColumns { get; set; } = "[]";
    public string? SortBy { get; set; }
    public string? CodeColumn { get; set; }
    public string? DescColumn { get; set; }
    public string AdditionalColumns { get; set; } = "[]";
}
```

### Models/LoanStatusCategoryEntity.cs

```csharp
namespace LookupApi.Common.Models; public class LoanStatusCategoryEntity { ... }
```

### Models/LoanStatusEntity.cs

```csharp
namespace LookupApi.Common.Models; public class LoanStatusEntity { ... }
```

### Controllers/LookupController.cs

```csharp
using Microsoft.AspNetCore.Mvc;
using Shared.LookupService.Services;

[ApiController]
[Route("api/[controller]")]
public class LookupController : ControllerBase
{
    private readonly ILookupDataService _lookup;
    public LookupController(ILookupDataService lookup) => _lookup = lookup;

    [HttpGet("{key}")]
    public async Task<IActionResult> Get(string key)
        => Ok(await _lookup.GetAsync(key));

    [HttpGet("{key}/filter")]  
    public async Task<IActionResult> GetFiltered(string key, [FromQuery] Dictionary<string, object> filters)
        => Ok(await _lookup.GetAsync(key, filters));
}
```

### Program.cs

```csharp
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddLookupDefinitions(builder.Configuration, "Db");
var app = builder.Build();
app.MapControllers();
app.Run();
```
