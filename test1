public/config.json
{
  "apiUrl": "https://api-dev.example.com",
  "ssoConfig": {
    "issuer": "https://idp.example.com/realms/dev",
    "clientId": "spa-dev",
    "scope": "openid profile email offline_access api.read",
    "requireHttps": true
  },
  "monitoring": {
    "endpoint": "https://mon-dev.example.com/events",
    "enabled": true
  },
  "security": {
    "contentSecurityPolicy": "default-src 'self';",
    "featurePolicy": "geolocation 'none'"
  }
}

angular.json (assets mapping)
"assets": [
  "src/favicon.ico",
  "src/assets",
  { "input": "public", "glob": "**/*", "output": "/" }
]

src/app/environment-config.service.ts
import { Injectable } from '@angular/core';

export class SSOConfig {
  issuer!: string;
  clientId!: string;
  scope?: string;
  requireHttps?: boolean;

  static fromJSON(j: any): SSOConfig {
    const x = new SSOConfig();
    x.issuer = String(j?.issuer ?? '');
    x.clientId = String(j?.clientId ?? '');
    x.scope = j?.scope ?? 'openid profile email';
    x.requireHttps = j?.requireHttps ?? true;
    if (!x.issuer || !x.clientId) throw new Error('ssoConfig.issuer/clientId required');
    return x;
  }
}

export class MonitoringConfig {
  endpoint!: string;
  enabled = false;
  static fromJSON(j: any): MonitoringConfig {
    const x = new MonitoringConfig();
    x.endpoint = String(j?.endpoint ?? '');
    x.enabled = Boolean(j?.enabled ?? false);
    return x;
  }
}

export class SecurityConfig {
  contentSecurityPolicy?: string;
  featurePolicy?: string;
  static fromJSON(j: any): SecurityConfig {
    const x = new SecurityConfig();
    x.contentSecurityPolicy = j?.contentSecurityPolicy ?? undefined;
    x.featurePolicy = j?.featurePolicy ?? undefined;
    return x;
  }
}

/** Your existing EnvironmentConfig, now injectable and loaded from /config.json */
@Injectable({ providedIn: 'root' })
export class EnvironmentConfig {
  apiUrl!: string;
  ssoConfig!: SSOConfig;
  monitoring!: MonitoringConfig;
  security!: SecurityConfig;

  async load(): Promise<void> {
    const base = document.baseURI?.replace(/\/+$/, '') ?? '';
    const url = `${base}/config.json?v=${Date.now()}`;
    const resp = await fetch(url, { cache: 'no-store' });
    if (!resp.ok) throw new Error(`config.json load failed: ${resp.status}`);
    const j = await resp.json();

    this.apiUrl = String(j?.apiUrl ?? '');
    if (!this.apiUrl) throw new Error('config.json: apiUrl required');

    this.ssoConfig = SSOConfig.fromJSON(j?.ssoConfig ?? {});
    this.monitoring = MonitoringConfig.fromJSON(j?.monitoring ?? {});
    this.security = SecurityConfig.fromJSON(j?.security ?? {});
  }
}

src/app/auth/auth.service.ts
import { Injectable } from '@angular/core';
import { OAuthService, AuthConfig } from 'angular-oauth2-oidc';
import { EnvironmentConfig } from '../environment-config.service';
import { BehaviorSubject, firstValueFrom } from 'rxjs';
import { filter, take } from 'rxjs/operators';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private refreshInProgress$ = new BehaviorSubject<boolean>(false);
  private refreshDone$       = new BehaviorSubject<boolean>(true);
  private firstLoginResolved = false;

  constructor(private oauth: OAuthService, private env: EnvironmentConfig) {}

  /** Called from provideAppInitializer after env.load() */
  async init(): Promise<void> {
    this.oauth.configure(this.toAuthConfig());
    await this.oauth.loadDiscoveryDocument();
    await this.oauth.tryLoginCodeFlow();

    const maybeResolveFirst = () => {
      if (!this.firstLoginResolved && this.oauth.hasValidAccessToken()) this.firstLoginResolved = true;
    };
    maybeResolveFirst();

    this.oauth.events.subscribe((e: any) => {
      if (e.type === 'token_received' || e.type === 'token_refreshed') this.schedulePreemptive();
      maybeResolveFirst();
    });

    if (this.oauth.hasValidAccessToken()) this.schedulePreemptive();
  }

  async waitForFirstLogin(): Promise<void> {
    if (this.firstLoginResolved) return;
    await firstValueFrom((this.oauth.events as any).pipe(
      filter(() => this.oauth.hasValidAccessToken()),
      take(1)
    ));
  }

  login(): void { this.oauth.initLoginFlow(); }
  logout(): void { this.oauth.logOut(true); }

  get accessToken(): string | null { return this.oauth.getAccessToken() || null; }
  hasValidAccessToken(): boolean { return this.oauth.hasValidAccessToken(); }

  async ensureFreshToken(): Promise<void> {
    const msLeft = this.oauth.getAccessTokenExpiration() - Date.now();
    if (!this.oauth.hasValidAccessToken() || msLeft < 60_000) await this.refreshIfPossible();
  }

  async refreshIfPossible(): Promise<void> {
    if (this.refreshInProgress$.value) {
      await firstValueFrom(this.refreshDone$.pipe(filter(v => v === true), take(1)));
      return;
    }
    const hasRT = !!this.oauth.getRefreshToken();
    if (!hasRT) throw new Error('NO_REFRESH_TOKEN');

    this.refreshInProgress$.next(true);
    this.refreshDone$.next(false);
    try {
      const ok = await this.oauth.refreshToken();
      if (!ok) throw new Error('REFRESH_FAILED');
    } finally {
      this.refreshInProgress$.next(false);
      this.refreshDone$.next(true);
    }
  }

  private schedulePreemptive(): void {
    const exp = this.oauth.getAccessTokenExpiration();
    const ms = Math.max(exp - Date.now() - 60_000, 0);
    setTimeout(() => {
      if (this.oauth.getAccessTokenExpiration() <= Date.now() + 90_000) {
        this.refreshIfPossible().catch(() => {});
      }
    }, ms);
  }

  private toAuthConfig(): AuthConfig {
    const a = this.env.ssoConfig;
    return {
      issuer: a.issuer,
      clientId: a.clientId,
      responseType: 'code',
      oidc: true,
      scope: a.scope ?? 'openid profile email',
      requireHttps: a.requireHttps ?? true,
      useSilentRefresh: false,      // per your requirement
      sessionChecksEnabled: false,
      disableAtHashCheck: true
    };
  }
}

src/app/auth/auth.interceptor.ts
import { Injectable } from '@angular/core';
import {
  HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse
} from '@angular/common/http';
import { Observable, from } from 'rxjs';
import { switchMap, catchError, throwError } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  constructor(private auth: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const addAuth = (r: HttpRequest<any>) => {
      const t = this.auth.accessToken;
      return t ? r.clone({ setHeaders: { Authorization: `Bearer ${t}` } }) : r;
    };

    return from(this.auth.ensureFreshToken()).pipe(
      switchMap(() => next.handle(addAuth(req))),
      catchError(err => {
        if (!this.isExpired(err)) return throwError(() => err);
        return from(this.auth.refreshIfPossible()).pipe(
          switchMap(() => next.handle(addAuth(req))),
          catchError(err2 => {
            this.auth.logout();
            this.auth.login();
            return throwError(() => err2);
          })
        );
      })
    );
  }

  private isExpired(err: any): boolean {
    if (err instanceof HttpErrorResponse) {
      if (err.status === 401) return true;
      const hdr = err.headers?.get('WWW-Authenticate') ?? '';
      if (hdr.includes('invalid_token') || hdr.includes('expired')) return true;
      const msg = ((err.error && (err.error.error || err.error.message)) || '') + '';
      if (msg.includes('invalid_token') || msg.includes('expired')) return true;
    }
    return false;
  }
}

src/app/session-bootstrap.service.ts
import { Injectable } from '@angular/core';
import { AuthService } from './auth/auth.service';
import { UserService } from './services/user.service';
import { MonitoringService } from './services/monitoring.service';

@Injectable({ providedIn: 'root' })
export class SessionBootstrapService {
  private booted = false;

  constructor(
    private auth: AuthService,
    private user: UserService,
    private mon: MonitoringService
  ) {}

  /** Run heavy stuff once after the FIRST valid token. Never on refresh. */
  async initOnce(): Promise<void> {
    if (this.booted) return;
    await this.auth.waitForFirstLogin();
    await this.user.loadProfile();
    await this.mon.init();
    this.booted = true;
  }
}

src/app/services/user.service.ts (stub)
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { EnvironmentConfig } from '../environment-config.service';
import { firstValueFrom } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class UserService {
  profile: any;
  private base = this.env.apiUrl;

  constructor(private http: HttpClient, private env: EnvironmentConfig) {}

  async loadProfile(): Promise<void> {
    this.profile = await firstValueFrom(this.http.get(`${this.base}/me`));
  }
}

src/app/services/monitoring.service.ts (stub)
import { Injectable } from '@angular/core';
import { EnvironmentConfig } from '../environment-config.service';

@Injectable({ providedIn: 'root' })
export class MonitoringService {
  private started = false;
  constructor(private env: EnvironmentConfig) {}

  async init(): Promise<void> {
    if (this.started || !this.env.monitoring.enabled) return;
    // register session, start beacons using this.env.monitoring.endpoint, etc.
    this.started = true;
  }
}

src/app/app.module.ts (using provideAppInitializer())
import { NgModule, inject } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { OAuthModule } from 'angular-oauth2-oidc';
import { provideAppInitializer } from '@angular/core';

import { AppComponent } from './app.component';
import { EnvironmentConfig } from './environment-config.service';
import { AuthService } from './auth/auth.service';
import { SessionBootstrapService } from './session-bootstrap.service';
import { AuthInterceptor } from './auth/auth.interceptor';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, HttpClientModule, OAuthModule.forRoot()],
  providers: [
    // Startup order: 1) config.json  2) OAuth discovery/login  3) boot ONCE
    provideAppInitializer(() => {
      const env  = inject(EnvironmentConfig);
      const auth = inject(AuthService);
      const boot = inject(SessionBootstrapService);
      return (async () => {
        await env.load();        // ALWAYS first
        await auth.init();       // uses env.ssoConfig
        if (auth.hasValidAccessToken()) await boot.initOnce();
      })();
    }),
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule {}

src/app/app.component.ts (keep clean)
import { Component } from '@angular/core';
@Component({ selector: 'app-root', template: `<router-outlet></router-outlet>` })
export class AppComponent {}

What this guarantees

/config.json loads before OAuth.

Token refresh only swaps tokens. It does not re-load config or re-run UserService/MonitoringService.

Heavy boot (SessionBootstrapService.initOnce()) runs once after the first valid token.

Interceptor pre-empts expiry, does single-flight refresh, retries once, and hard-reauths if refresh isn’t possible.

If your config.json keys differ, tell me the exact shape; I’ll tweak EnvironmentConfig.load() and toAuthConfig() accordingly.
