// --------------------------------------------------------------------
// File: libs/core/lookup/state/lookup.effects.ts
// --------------------------------------------------------------------
import { Injectable } from '@angular/core';
import { Actions, createEffect, ofType } from '@ngrx/effects';
import { Store, select } from '@ngrx/store';
import { of } from 'rxjs';
import { catchError, concatMap, filter, map, mergeMap, withLatestFrom } from 'rxjs/operators';
import * as LookupActions from './lookup.actions';
import { LookupService } from '../lookup.service';
import { selectLookupItems } from './lookup.selectors';
import { serializeParams } from './lookup.utils';

@Injectable()
export class LookupEffects {
  /**
   * Load a single lookup only if not already in store
   */
  load$ = createEffect(() =>
    this.actions$.pipe(
      ofType(LookupActions.loadLookup),
      concatMap(action =>
        of(action).pipe(
          withLatestFrom(
            this.store.pipe(select(selectLookupItems(action.name, action.uiParams)))
          )
        )
      ),
      filter(([_, items]) => items.length === 0),
      mergeMap(([{ name, uiParams }]) =>
        this.lookupService.get(name, uiParams).pipe(
          map(items =>
            LookupActions.loadLookupSuccess({
              name,
              items,
              uiParamsKey: serializeParams(uiParams)
            })
          ),
          catchError(error =>
            of(LookupActions.loadLookupFailure({ name, error }))
          )
        )
      )
    )
  );

  /**
   * Load multiple lookups in one call, only if any are not already loaded
   */
  loadMany$ = createEffect(() =>
    this.actions$.pipe(
      ofType(LookupActions.loadLookups),
      concatMap(action =>
        of(action).pipe(
          withLatestFrom(
            ...action.names.map(name =>
              this.store.pipe(select(selectLookupItems(name, action.uiParams)))
            )
          )
        )
      ),
      filter(([action, ...arrays]) =>
        // only proceed if at least one lookup is empty
        arrays.some(items => items.length === 0)
      ),
      mergeMap(([{ names, uiParams }]) =>
        this.lookupService.getMany(names, uiParams).pipe(
          map(results =>
            LookupActions.loadLookupsSuccess({
              results,
              uiParamsKey: serializeParams(uiParams)
            })
          ),
          catchError(error =>
            of(LookupActions.loadLookupsFailure({ names, error }))
          )
        )
      )
    )
  );

  constructor(
    private actions$: Actions,
    private store: Store,
    private lookupService: LookupService
  ) {}
}
