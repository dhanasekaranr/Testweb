using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using MyApi.Provider.Auth;
using MyApi.Provider.Options;
using MyApi.Service.Monitoring;
using MyApi.Service.Options;
using MyApi.Service.Shared;


namespace MyApi.Service.Extensions;


public static class MonitoringServiceCollectionExtensions
{
public static IServiceCollection AddMonitoringPipeline(this IServiceCollection services, IConfiguration config)
{
// Bind Monitoring section for Service (includes Auth nested options)
services.AddOptions<MonitoringOptions>()
.Bind(config.GetSection("Monitoring"))
.Validate(o => !string.IsNullOrWhiteSpace(o.Api), "Monitoring.Api required")
.Validate(o => !string.IsNullOrWhiteSpace(o.Auth.ClientId), "Monitoring.Auth.ClientId required")
.Validate(o => !string.IsNullOrWhiteSpace(o.Auth.ClientSecret), "Monitoring.Auth.ClientSecret required")
.Validate(o => !string.IsNullOrWhiteSpace(o.Auth.TokenEndpoint), "Monitoring.Auth.TokenEndpoint required")
.ValidateOnStart();


// Also bind Provider's Auth options to the same subtree
services.AddOptions<MonitoringAuthOptions>()
.Bind(config.GetSection("Monitoring:Auth"))
.Validate(o => !string.IsNullOrWhiteSpace(o.ClientId), "ClientId required")
.Validate(o => !string.IsNullOrWhiteSpace(o.ClientSecret), "ClientSecret required")
.Validate(o => !string.IsNullOrWhiteSpace(o.TokenEndpoint), "TokenEndpoint required")
.ValidateOnStart();


// Token cache (in-memory now; swap to Redis later without code changes)
services.AddDistributedMemoryCache();
services.AddHttpClient();


// Queue + sender + hosted dispatcher
services.AddSingleton<IBackgroundQueue<MonitoringEvent>>(sp =>
{
var qopt = sp.GetRequiredService<IOptions<MonitoringOptions>>().Value.Queues;
return new BackgroundQueue<MonitoringEvent>(qopt);
});
services.AddSingleton<IMonitoringTokenProvider, MonitoringTokenProvider>();
services.AddSingleton<IOutboundSender<MonitoringEvent>, MonitoringSender>();
services.AddHostedService(sp =>
{
var q = sp.GetRequiredService<IBackgroundQueue<MonitoringEvent>>();
var s = sp.GetRequiredService<IOutboundSender<MonitoringEvent>>();
var opts = sp.GetRequiredService<IOptions<MonitoringOptions>>().Value.Queues;
var log = sp.GetRequiredService<Microsoft.Extensions.Logging.ILogger<BackgroundDispatcher<MonitoringEvent>>>();
return new BackgroundDispatcher<MonitoringEvent>(q, s, opts, log);
});


return services;
}
}
