# VB6 → Angular 21 UI Generator (VS Code Extension)
## End-to-end Architecture & Flow (Angular UI only)

> Scope: VB6 Form (`.frm`) → Angular 21 **UI screen** generation only.  
> Out of scope: .NET API generation, database mappings, backend workflows.

---

## 1) Goal

Build a VS Code extension that, given a VB6 Form, generates an Angular 21 screen that:

- Uses **our shared UI primitives** (SharedMatTable, SharedTabGroup, FormBuilder, PageLayout/Container, etc.)
- Follows **our base patterns** (BaseComponent, BaseService, BasePageDto, shared libs)
- Produces **thin screen code** (mostly wiring) + **config-driven UI**
- Stays consistent with “golden screens”
- Optionally minimizes premium model usage (cheap-first strategy)

---

## 2) Non-negotiable Principles

### 2.1 Contract-first generation
The generator does **not** freehand Angular UI. It produces:
1) **ScreenSpec IR** (intermediate representation)
2) **ScreenConfig** (typed configs for shared components)
3) **Thin Angular wrapper** (component + template rendering configs)

### 2.2 Shared UI primitives only
Generated output must use shared components only:
- `PageLayout / Container`
- `SharedTabGroup`
- `FormBuilder`
- `SharedMatTable`
- other shared components (dialogs, lookup, banners, etc.)

**Anti-patterns (must block / warn hard):**
- Direct usage of `MatTable`, `MatTabGroup`
- Bespoke HTML layouts (div soup)
- Inline reactive forms / hand-built FormGroups in templates
- Complex UI logic in the screen component that belongs in shared components/config

### 2.3 Golden screens are the canonical truth
The repo must contain “perfect” reference screens. Output must align to them, not invent patterns.

---

## 3) Repo Folder Structure (Extension Inputs + Generated Outputs)

This is the **single merged folder structure** the extension depends on. Adjust paths to your monorepo conventions, but keep the intent.

### 3.1 Extension-consumed assets (must exist in repo)

ui-kit-catalog/
├─ README.md
├─ anti-patterns.md
├─ mapping/
│ ├─ vb-control-map.md
│ └─ rules.md
├─ patterns/
│ ├─ basecomponent.md
│ ├─ baseservice.md
│ └─ pagedto.md
├─ screen-spec/
│ ├─ screen-spec.schema.json # or: screen-spec.types.ts
│ └─ examples/
│ ├─ simple-form.spec.json
│ └─ tabbed-form-and-grid.spec.json
├─ components/
│ ├─ page-layout/
│ │ ├─ contract.ts
│ │ ├─ schema.json
│ │ └─ examples/
│ │ ├─ full-page.md
│ │ └─ two-column.md
│ ├─ shared-tab-group/
│ │ ├─ contract.ts
│ │ ├─ schema.json
│ │ └─ examples/
│ │ ├─ lazy-load.md
│ │ └─ eager-load.md
│ ├─ form-builder/
│ │ ├─ contract.ts
│ │ ├─ schema.json
│ │ └─ examples/
│ │ ├─ borrower-form.md
│ │ ├─ validations.md
│ │ └─ field-types.md
│ └─ shared-mat-table/
│ ├─ contract.ts
│ ├─ schema.json
│ └─ examples/
│ ├─ basic.md
│ ├─ editable-rows.md
│ └─ row-actions.md
└─ golden-screens/
├─ borrower/
│ ├─ borrower.component.ts
│ ├─ borrower.component.html
│ ├─ borrower.config.ts
│ └─ README.md
├─ employment/
│ ├─ employment.component.ts
│ ├─ employment.component.html
│ ├─ employment.config.ts
│ └─ README.md
└─ payments/
├─ payments.component.ts
├─ payments.component.html
├─ payments.config.ts
└─ README.md




**Minimum requirement per shared component**
- `contract.ts` (TypeScript interfaces = source of truth)
- `schema.json` (validation for configs)
- `examples/` (2–5 golden samples; this is what keeps output consistent)

---

### 3.2 Generated artifacts (created by the extension)

generated/
└─ <screenId>/
├─ screen.spec.json # ScreenSpec IR output
├─ migration-report.md # mapping summary + TODOs + assumptions + gates
└─ debug/ # optional but useful
├─ parse-model.json # raw parsed VB form model
└─ validation-results.json # lint/build/test output snapshots



---

## 4) Output Contract (What the Generator Produces)

Given one VB Form:

1) **ScreenSpec IR**
- Path: `/generated/<screenId>/screen.spec.json`
- Purpose: normalized structure describing layout, widgets, bindings, events, validations, tables

2) **ScreenConfig**
- Path: `/apps/<app>/src/app/features/<feature>/<screenId>/<screenId>.config.ts`
- Purpose: typed config objects for shared primitives (FormBuilder, SharedMatTable, SharedTabGroup, PageLayout)

3) **Angular Screen Wrapper (thin)**
- Paths:
  - `<screenId>.component.ts/html/scss`
- Purpose:
  - extends your base component (BaseComponent/BasePageComponent)
  - references config
  - renders shared primitives only

4) **Migration Report**
- Path: `/generated/<screenId>/migration-report.md`
- Contains:
  - VB → shared mapping summary
  - unsupported controls + TODOs
  - assumptions/inferences
  - quality gate outputs

---

## 5) End-to-End Flow (Step-by-step)

### Step 0 — Trigger generation
Entry points:
- Command Palette: `VB6: Generate Angular Screen from Form`
- Optional Chat Participant: `@vb6-migrator /convert-form`

Wizard inputs:
- Select `.frm`
- Select target Angular app + feature folder/library
- Select cost profile: `Economy / Balanced / Premium`
- Defaults:
  - tab strategy: lazy/eager
  - table mode: readonly/editable
  - form strategy: config-only (recommended always)

---

### Step 1 — VB Form ingestion (local, deterministic)
Read:
- `.frm` for layout + control definitions
- `.frx` resources if needed
- optional `.bas/.cls` to discover handler signatures (optional phase)

Output a **parse model**:
- Control tree (frames, tabs, grids, input controls)
- Properties (caption, visible, enabled, maxLength, etc.)
- Events list (Click, Change, Validate, LostFocus, etc.)

✅ No LLM required.

---

### Step 2 — Build ScreenSpec IR (local + optional refine)
Convert parse model → `screen.spec.json`.

ScreenSpec should include:
- `screenId`, `route`, `title`
- `layout` structure (containers/cards/sections)
- `widgets` (tabs/forms/tables)
- `fields` (type, label, mask, validators, dtoKey)
- `tables` (columns, row actions)
- `events` (source → handler name)
- `unsupported[]` list for unmappable items

Optional LLM tasks:
- normalize naming (VB control names → clean camelCase)
- infer field types (date/number/text)
- infer validators based on VB properties

If LLM is used:
- record assumptions in report.

---

### Step 3 — Mapping Engine: VB → Shared UI primitives (rules-based)
Apply deterministic mapping rules from:

- `/ui-kit-catalog/mapping/vb-control-map.md`
- `/ui-kit-catalog/mapping/rules.md`

Examples:
- VB `SSTab` / TabStrip → `SharedTabGroup`
- VB `MSFlexGrid` / ListView → `SharedMatTable`
- VB `TextBox` / `ComboBox` / `CheckBox` → `FormBuilder` fields
- VB `Frame` / group container → `PageLayout` section/card

Guardrails:
- If tabs exist: must generate `SharedTabGroup` config
- All fields declared in FormBuilder config
- All grids declared in SharedMatTable config
- Never generate direct Material components

If mapping fails:
- add to `unsupported[]`
- generate TODO placeholders + report entries

---

### Step 4 — Config generation (contract-driven)
Generate:
- `layoutConfig`
- `tabGroupConfig`
- `formConfig` per tab/section
- `tableConfig` per grid

Validation:
- Validate config against each component’s `schema.json`
- Fail fast if invalid (do not generate broken screens)

---

### Step 5 — Angular wrapper generation (thin code only)
Generate:
- `<screenId>.component.ts`: extends BaseComponent/BasePageComponent, wires config, handler stubs
- `<screenId>.component.html`: renders shared primitives only
- `<screenId>.component.scss`: minimal styling

Allowed in TS:
- `cfg` reference
- lifecycle wiring
- handler stubs (TODO)
- calls into base service patterns

Not allowed:
- bespoke layout logic
- manual reactive forms
- custom table logic

---

### Step 6 — Workspace integration
Use VS Code `WorkspaceEdit` to atomically:
- create folders
- write files
- update route registration (optional)
- update exports/barrels (optional)
- update navigation (optional)

---

### Step 7 — Quality gates
Run (recommended):
- `ng lint`
- `ng test` (optional)
- `ng build <app>` (recommended)

On failure:
- collect and surface errors
- attempt deterministic fixes first (imports, exports, missing references)
- only then escalate to LLM fix (balanced first, premium last)

---

### Step 8 — Finalization
Show:
- generated files list
- unsupported mapping list
- TODO list
- gate results
- confidence score (optional)

Write:
- `/generated/<screenId>/migration-report.md`

---

## 6) Model / Cost Routing Strategy (Recommended)

### 6.1 Cheap-first approach
1) Parse + map locally (no model)
2) Economy model:
   - naming normalization
   - light inference (field types, validators)
3) Balanced model:
   - config refinement
   - handler stubs aligned to base patterns
4) Premium model:
   - only if repeated build/lint failures or complex mapping

### 6.2 Extension settings
- `vbMigrator.model.economy`
- `vbMigrator.model.balanced`
- `vbMigrator.model.premium`
- `vbMigrator.costProfile` per run

---

## 7) VS Code Extension Responsibilities

### 7.1 Commands
- `VB6: Convert Form → ScreenSpec`
- `VB6: Generate Angular from ScreenSpec`
- `VB6: Full Convert (Form → Angular)`
- `VB6: Validate Generated Screen`

### 7.2 Optional Chat Participant
`@vb6-migrator`
- `/convert-form`
- `/generate-ui`
- `/validate`

### 7.3 Tools for Copilot agent mode (optional)
Expose tools:
- `extractScreenSpec(formPath)`
- `generateScreenConfig(screenSpecPath)`
- `generateAngularScreen(screenSpecPath, targetPath)`
- `runNgGates(appName)`
- `writeMigrationReport(screenSpecPath, results)`

---

## 8) Acceptance Criteria (Definition of Done)

A successful conversion means:
- Angular 21 build compiles the screen
- Output uses only shared components (no raw Material tabs/tables/forms)
- Config validates against schemas
- Folder structure matches monorepo conventions
- Migration report includes unsupported items + TODOs
- Lint passes or errors are actionable and mapped to fixes

---

## 9) Common Failure Modes (Avoid)

- Feeding raw VB6 directly to the model to “write Angular”
- Generating bespoke layouts instead of PageLayout/Container
- Building reactive forms manually instead of FormBuilder config
- Letting model pick components instead of catalog/rules
- Not validating configs (silent broken output)
- No golden screens (output drifts over time)

---

## 10) One-page Summary

**Pipeline**:  
`VB6 Form → Parser → ScreenSpec IR → Mapping Rules → Shared Configs → Thin Angular Wrapper → Gates → Report`

**Guardrails**:  
Shared components only • Config-driven UI • Schema validation • Golden screens are canonical • Cheap-first model routing

---



   └─ src/
      └─ app/
         └─ features/
            └─ underwriting/
               ├─ feature.routes.ts
               ├─ feature.nav.ts
               └─ borrower/
                  ├─ borrower.component.ts
                  ├─ borrower.component.html
                  ├─ borrower.component.scss
                  ├─ borrower.config.ts
                  ├─ index.ts
                  └─ README.md
