1) OAuth config
// src/app/auth/oauth.config.ts
import { AuthConfig } from 'angular-oauth2-oidc';

export const authConfig: AuthConfig = {
  issuer: 'https://your-idp.example.com',        // <-- your issuer
  clientId: 'your-client-id',                    // <-- your client id
  redirectUri: window.location.origin + '/auth/callback',
  postLogoutRedirectUri: window.location.origin,
  responseType: 'code',
  scope: 'openid profile email offline_access',  // offline_access => refresh_token
  useSilentRefresh: false,                       // don’t use iframe
  showDebugInformation: false,
  sessionChecksEnabled: false,
  // Stronger default storage: sessionStorage reduces blast radius vs localStorage
  // (You can switch to localStorage if you must keep sessions across tabs/restarts.)
  customQueryParams: { prompt: 'consent' }       // optional for some IdPs to issue RT
};


If your IdP requires explicit consent or specific scopes to return RTs, keep offline_access and (optionally) prompt=consent.

2) AuthService (refresh-on-demand + proactive timer + single-flight)
// src/app/auth/auth.service.ts
import { Injectable, NgZone } from '@angular/core';
import { OAuthService, OAuthEvent, OAuthSuccessEvent } from 'angular-oauth2-oidc';
import { authConfig } from './oauth.config';
import { firstValueFrom, Subject } from 'rxjs';

const REFRESH_MARGIN_SEC = 60;  // refresh this many seconds before exp
const CLOCK_SKEW_SEC = 10;      // safety for minor clock drift

@Injectable({ providedIn: 'root' })
export class AuthService {
  private tokenTimer: any = null;
  private refreshInFlight = false;
  private waiters = new Subject<void>();

  constructor(private oauth: OAuthService, private zone: NgZone) {}

  async init(): Promise<void> {
    this.oauth.configure(authConfig);

    // Load OIDC metadata and finish code flow if ?code= is present
    await this.oauth.loadDiscoveryDocumentAndTryLogin();

    // If we still aren’t authenticated, start login
    if (!this.oauth.hasValidAccessToken()) {
      await this.login();
      return;
    }

    // Set up proactive refresh timer
    this.scheduleProactive();

    // Re-schedule when tokens change or app "wakes up"
    this.oauth.events.subscribe((e: OAuthEvent) => {
      if (
        e instanceof OAuthSuccessEvent &&
        (e.type === 'token_received' || e.type === 'token_refreshed')
      ) {
        this.scheduleProactive();
      }
    });
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') this.scheduleProactive();
    });
    window.addEventListener('online', () => this.scheduleProactive());
  }

  async login(): Promise<void> {
    await this.oauth.initLoginFlow(); // redirects to IdP; returns after redirect back
  }

  logout(): void {
    try { this.oauth.logOut(); } finally { if (this.tokenTimer) clearTimeout(this.tokenTimer); }
  }

  get accessToken(): string | null {
    return this.oauth.getAccessToken() || null;
  }

  get refreshToken(): string | null {
    // angular-oauth2-oidc stores RT when offline_access is enabled and IdP returns it
    return (this.oauth as any).getRefreshToken?.() ?? null;
  }

  get expiresAt(): number | null {
    return this.oauth.getAccessTokenExpiration() || null; // ms epoch
  }

  /**
   * Ensure we have a valid token: refresh if within margin/expired.
   * Concurrency-safe: one refresh flight; others await.
   */
  async ensureValidToken(): Promise<void> {
    const exp = this.expiresAt ?? 0;
    const now = Date.now();
    const marginMs = (REFRESH_MARGIN_SEC + CLOCK_SKEW_SEC) * 1000;

    // If token is valid far enough into the future, nothing to do.
    if (this.oauth.hasValidAccessToken() && exp && now + marginMs < exp) return;

    // If we have no refresh token, we can’t background refresh: re-auth.
    const rt = this.refreshToken;
    if (!rt) {
      await this.login();
      return;
    }

    // Single-flight
    if (this.refreshInFlight) {
      await firstValueFrom(this.waiters.asObservable());
      return;
    }

    this.refreshInFlight = true;
    try {
      const result = await this.oauth.refreshToken(); // uses RT grant under the hood
      if (!result) {
        // Some IdPs return empty object on failure without throwing
        await this.login();
      }
    } catch {
      // RT invalid/rotated/revoked => force re-auth
      await this.login();
    } finally {
      this.refreshInFlight = false;
      this.waiters.next(); // release queued callers
    }
  }

  private scheduleProactive(): void {
    if (this.tokenTimer) clearTimeout(this.tokenTimer);
    const exp = this.expiresAt;
    if (!exp) return;

    const target = exp - REFRESH_MARGIN_SEC * 1000;
    const delay = Math.max(0, target - Date.now());

    this.zone.runOutsideAngular(() => {
      this.tokenTimer = setTimeout(() => {
        // fire refresh ahead of time; interceptor also covers just-in-time cases
        void this.ensureValidToken();
      }, delay);
    });
  }
}

3) HTTP interceptor (attach token, block during refresh, retry once on 401)
// src/app/auth/auth.interceptor.ts
import { Injectable, inject } from '@angular/core';
import {
  HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse
} from '@angular/common/http';
import { Observable, from, throwError } from 'rxjs';
import { catchError, switchMap } from 'rxjs/operators';
import { AuthService } from './auth.service';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private auth = inject(AuthService);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const proceed = () => next.handle(this.attach(req));

    return from(this.auth.ensureValidToken()).pipe(
      switchMap(() => proceed()),
      catchError((err: any) => {
        // If the request failed with 401, try one forced refresh (or login)
        if (err instanceof HttpErrorResponse && err.status === 401) {
          return from(this.auth.ensureValidToken()).pipe(switchMap(() => proceed()));
        }
        return throwError(() => err);
      })
    );
  }

  private attach(req: HttpRequest<any>): HttpRequest<any> {
    const token = this.auth.accessToken;
    if (!token) return req;
    return req.clone({ setHeaders: { Authorization: `Bearer ${token}` } });
  }
}

4) Application wiring (standalone bootstrap)
// src/main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { provideHttpClient, withInterceptors } from '@angular/common/http';
import { AppComponent } from './app/app.component';
import { AuthInterceptor } from './app/auth/auth.interceptor';
import { AuthService } from './app/auth/auth.service';

bootstrapApplication(AppComponent, {
  providers: [
    provideHttpClient(withInterceptors([ (req, next) => new AuthInterceptor().intercept(req, next) ]))
  ]
}).then(async ref => {
  const auth = ref.injector.get(AuthService);
  await auth.init(); // Initialize OIDC before app starts hitting APIs
});


NgModule app instead? Register the interceptor with multi: true under HTTP_INTERCEPTORS, and call await auth.init() in AppComponent’s init path or an APP_INITIALIZER (Angular 19 still supports it).

5) Optional: Route guard (blocks routes until authenticated)
// src/app/auth/auth.guard.ts
import { inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from './auth.service';

export const authGuard: CanActivateFn = async () => {
  const auth = inject(AuthService);
  const router = inject(Router);
  if (!auth.accessToken) {
    await auth.login();
    return false; // navigation will continue after redirect back
  }
  await auth.ensureValidToken(); // make sure it's fresh enough
  return true;
};


Use it on protected routes:

// src/app/app.routes.ts
import { Routes } from '@angular/router';
import { authGuard } from './auth/auth.guard';

export const routes: Routes = [
  { path: '', loadComponent: () => import('./home/home.component').then(m => m.HomeComponent) },
  { path: 'secure', canActivate: [authGuard], loadComponent: () => import('./secure/secure.component').then(m => m.SecureComponent) },
];

6) (Nice-to-have) Multi-tab single-refresh (avoid multiple tabs hitting /token)

Add this inside AuthService if you run multi-tab:

private bc = typeof BroadcastChannel !== 'undefined' ? new BroadcastChannel('auth') : null;

constructor(private oauth: OAuthService, private zone: NgZone) {
  // ...
  this.bc?.addEventListener('message', async (e: MessageEvent) => {
    if (e.data === 'refresh-start') {
      this.refreshInFlight = true;
    } else if (e.data === 'refresh-done') {
      this.refreshInFlight = false;
      this.waiters.next();
      this.scheduleProactive();
    }
  });
}

async ensureValidToken(): Promise<void> {
  // ... before starting refresh:
  if (!this.refreshInFlight) this.bc?.postMessage('refresh-start');
  try {
    const result = await this.oauth.refreshToken();
    // ...
  } finally {
    this.bc?.postMessage('refresh-done');
    // ...
  }
}

7) What changed vs your old setup

Scopes include offline_access.

No silent iframe. We use refreshToken() and a proactive timer + just-in-time refresh.

Requests never race with refresh: interceptor calls ensureValidToken() and queues.

401 safety: one retry after refresh; on failure, we hard redirect to login().

8) IdP knobs you must align with

Tell your SSO team this is what your client expects:

Grant: Authorization Code + PKCE.

Scopes: openid profile email offline_access.

Refresh Token Rotation: enabled, with reasonable TTL (e.g., RT TTL ≥ session length).

CORS: allow your SPA origin for /authorize, /token, and OIDC discovery endpoints.

SameSite for any IdP cookies: Lax is fine for code flow; Secure on HTTPS.

TL;DR

Drop silent refresh. Keep code flow + PKCE. Use offline_access. Implement the AuthService + AuthInterceptor above. You’ll refresh cleanly before expiry and your calls won’t 401-flap.
