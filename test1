// Models/UIFieldFilter.cs
public enum FilterOperator { Equals, Contains, GreaterThan, LessThan }

public class UIFieldFilter
{
    public string         Field    { get; set; } = null!;
    public FilterOperator Operator { get; set; }
    public object?        Value    { get; set; }
}


// Models/UIPageDTO.cs
public class UIPageDTO
{
    public int                 PageNumber { get; set; } = 1;
    public int                 PageSize   { get; set; } = 20;
    public string?             SortBy     { get; set; }
    public bool                SortDesc   { get; set; }
    public List<UIFieldFilter> Filters    { get; } = new();
}


// Models/ProductUIPageDTO.cs
public class ProductUIPageDTO : UIPageDTO
{
    public int?    Id               { get; set; }
    public string? Desc             { get; set; }
    public string? Code             { get; set; }
    public string? CreatedDtPattern { get; set; }
}


// Models/ProductDTO.cs
public class ProductDTO
{
    public int      Id          { get; set; }
    public string   Name        { get; set; } = null!;
    public string   SpecialCode { get; set; } = null!;
    public DateTime NoteDt      { get; set; }
}


// Models/PagedResult.cs
public record PagedResult<T>(
    IReadOnlyList<T> Items,
    int TotalCount,
    int PageNumber,
    int PageSize
)
{
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
}


// Mapping/MappingProfile.cs
using AutoMapper;

public class MappingProfile : Profile
{
    public MappingProfile()
    {
        // Populate filters in UIPageDTO
        CreateMap<ProductUIPageDTO, UIPageDTO>()
            .ForMember(d => d.Filters, o => o.Ignore())
            .AfterMap((src, dest) =>
            {
                if (src.Id.HasValue)
                    dest.Filters.Add(new UIFieldFilter {
                        Field    = nameof(src.Id),
                        Operator = FilterOperator.Equals,
                        Value    = src.Id.Value
                    });
                if (!string.IsNullOrWhiteSpace(src.Desc))
                    dest.Filters.Add(new UIFieldFilter {
                        Field    = nameof(src.Desc),
                        Operator = FilterOperator.Contains,
                        Value    = src.Desc!
                    });
                if (!string.IsNullOrWhiteSpace(src.Code))
                    dest.Filters.Add(new UIFieldFilter {
                        Field    = nameof(src.Code),
                        Operator = FilterOperator.Equals,
                        Value    = src.Code!
                    });
                if (!string.IsNullOrWhiteSpace(src.CreatedDtPattern))
                    dest.Filters.Add(new UIFieldFilter {
                        Field    = nameof(src.CreatedDtPattern),
                        Operator = FilterOperator.Contains,
                        Value    = src.CreatedDtPattern!
                    });
            });

        // Map UI â†’ Dapper DTO (NoteDt ignored)
        CreateMap<ProductUIPageDTO, ProductDTO>()
            .ForMember(d => d.Id,          o => o.MapFrom(s => s.Id ?? 0))
            .ForMember(d => d.Name,        o => o.MapFrom(s => s.Desc!))
            .ForMember(d => d.SpecialCode, o => o.MapFrom(s => s.Code!))
            .ForMember(d => d.NoteDt,      o => o.Ignore());
    }
}


// Services/DapperFilterBuilder.cs
using Dapper;
using AutoMapper;
using System.Text;

public class DapperFilterBuilder
{
    private readonly IReadOnlyDictionary<string,string> _columnMap;
    private readonly HashSet<string>                   _dateColumns;

    public DapperFilterBuilder(IConfigurationProvider mapperConfig)
    {
        var typeMap = mapperConfig.FindTypeMapFor<ProductUIPageDTO, ProductDTO>()!;

        _columnMap = typeMap.PropertyMaps
            .Where(pm => pm.SourceMember != null && pm.DestinationMember != null)
            .ToDictionary(
                pm => pm.SourceMember!.Name,
                pm => pm.DestinationMember!.Name,
                StringComparer.OrdinalIgnoreCase
            );

        _dateColumns = typeMap.PropertyMaps
            .Where(pm =>
                pm.DestinationType == typeof(DateTime) ||
                pm.DestinationType == typeof(DateTime?)
            )
            .Select(pm => pm.DestinationMember!.Name)
            .ToHashSet(StringComparer.OrdinalIgnoreCase);
    }

    public (string whereClause, DynamicParameters parameters)
      BuildSql(IEnumerable<UIFieldFilter> filters)
    {
        var sb = new StringBuilder("1=1");
        var dp = new DynamicParameters();
        int idx = 0;

        foreach (var f in filters)
        {
            var column = _columnMap.TryGetValue(f.Field, out var real)
                         ? real
                         : f.Field;
            var param  = $":p{idx}";

            if (f.Operator == FilterOperator.Contains
                && f.Value is string str
                && _dateColumns.Contains(column))
            {
                sb.Append($" AND TO_CHAR({column}, 'YYYY/MM/DD') LIKE {param}");
                dp.Add($"p{idx}", $"%{str}%");
                idx++;
                continue;
            }

            sb.Append($" AND {column} ");
            switch (f.Operator)
            {
                case FilterOperator.Equals:
                    sb.Append($"= {param}");
                    dp.Add($"p{idx}", f.Value);
                    idx++;
                    break;

                case FilterOperator.Contains:
                    sb.Append($"LIKE {param}");
                    dp.Add($"p{idx}", $"%{f.Value}%");
                    idx++;
                    break;

                case FilterOperator.GreaterThan:
                    sb.Append($"> {param}");
                    dp.Add($"p{idx}", f.Value);
                    idx++;
                    break;

                case FilterOperator.LessThan:
                    sb.Append($"< {param}");
                    dp.Add($"p{idx}", f.Value);
                    idx++;
                    break;
            }
        }

        return (sb.ToString(), dp);
    }
}


// Services/DapperPagingService.cs
using Dapper;
using System.Data;

public class DapperPagingService<TDto>
{
    private readonly IDbConnection       _conn;
    private readonly DapperFilterBuilder _filterBuilder;
    private readonly string              _tableName;

    public DapperPagingService(
        IDbConnection conn,
        DapperFilterBuilder filterBuilder,
        string tableName)
    {
        _conn          = conn;
        _filterBuilder = filterBuilder;
        _tableName     = tableName;
    }

    public async Task<PagedResult<TDto>> GetPagedAsync(UIPageDTO request)
    {
        var (where, dp) = _filterBuilder.BuildSql(request.Filters);

        var sql = $@"
            SELECT COUNT(1)
              FROM {_tableName}
             WHERE {where};

            SELECT *
              FROM {_tableName}
             WHERE {where}
             ORDER BY {(string.IsNullOrEmpty(request.SortBy) ? "Id" : request.SortBy)}
                     {(request.SortDesc ? "DESC" : "ASC")}
             OFFSET {(request.PageNumber-1)*request.PageSize} ROWS
             FETCH NEXT {request.PageSize} ROWS ONLY;";

        using var multi = await _conn.QueryMultipleAsync(sql, dp);
        var total = await multi.ReadFirstAsync<int>();
        var items = (await multi.ReadAsync<TDto>()).ToList();

        return new PagedResult<TDto>(items, total, request.PageNumber, request.PageSize);
    }
}


// Program.cs
using AutoMapper;
using System.Data;
using Oracle.ManagedDataAccess.Client;

var builder = WebApplication.CreateBuilder(args);

// AutoMapper
builder.Services.AddAutoMapper(typeof(MappingProfile));

// Temp SP to get mapper config
var spTemp       = builder.Services.BuildServiceProvider();
var mapperConfig = spTemp.GetRequiredService<IConfigurationProvider>();

// Filter builder
builder.Services.AddSingleton(new DapperFilterBuilder(mapperConfig));

// IDbConnection
builder.Services.AddScoped<IDbConnection>(sp =>
    new OracleConnection(builder.Configuration.GetConnectionString("Default")));

// Paging service
builder.Services.AddScoped(sp =>
    new DapperPagingService<ProductDTO>(
        sp.GetRequiredService<IDbConnection>(),
        sp.GetRequiredService<DapperFilterBuilder>(),
        tableName: "Products"
    )
);

builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();


// Controllers/ProductsController.cs
using Microsoft.AspNetCore.Mvc;

[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly DapperPagingService<ProductDTO> _paging;

    public ProductsController(DapperPagingService<ProductDTO> paging)
        => _paging = paging;

    [HttpGet]
    public async Task<ActionResult<PagedResult<ProductDTO>>> Get([FromQuery] ProductUIPageDTO ui)
    {
        var result = await _paging.GetPagedAsync(ui);
        return Ok(result);
    }
}









// models/filter.model.ts
export enum FilterOperator {
  Equals      = 'Equals',
  Contains    = 'Contains',
  GreaterThan = 'GreaterThan',
  LessThan    = 'LessThan'
}

export interface UIFieldFilter {
  field: string;
  operator: FilterOperator;
  value: any;
}

export interface UIPageDTO {
  pageNumber: number;
  pageSize:   number;
  sortBy?:    string;
  sortDesc?:  boolean;
  filters:    UIFieldFilter[];
}

// product-pagination.service.ts
import { Injectable } from '@angular/core';
import { HttpClient, HttpParams } from '@angular/common/http';
import { Observable } from 'rxjs';
import { UIPageDTO, UIFieldFilter, FilterOperator } from './models/filter.model';
import { PagedResult } from './models/paged-result.model';

@Injectable({ providedIn: 'root' })
export class ProductPaginationService {
  constructor(private http: HttpClient) {}

  getProducts(dto: UIPageDTO): Observable<PagedResult<any>> {
    let params = new HttpParams()
      .set('pageNumber', dto.pageNumber.toString())
      .set('pageSize', dto.pageSize.toString());
    if (dto.sortBy) {
      params = params.set('sortBy', dto.sortBy)
                     .set('sortDesc', String(dto.sortDesc));
    }
    dto.filters.forEach((f, i) => {
      params = params
        .set(`filters[${i}].field`, f.field)
        .set(`filters[${i}].operator`, f.operator)
        .set(`filters[${i}].value`, String(f.value));
    });
    return this.http.get<PagedResult<any>>('/api/products', { params });
  }
}

// app-product-table.component.ts  (child)
import { AfterViewInit, Component, ElementRef, EventEmitter, Input, Output, ViewChild } from '@angular/core';
import { fromEvent, merge } from 'rxjs';
import { debounceTime, distinctUntilChanged, map, startWith, switchMap, tap } from 'rxjs/operators';
import { UIPageDTO, UIFieldFilter, FilterOperator, ProductDTO, PagedResult } from './models/filter.model';
import { MatPaginator } from '@angular/material/paginator';
import { MatSort }      from '@angular/material/sort';

@Component({
  selector: 'app-product-table',
  templateUrl: './app-product-table.component.html'
})
export class AppProductTableComponent implements AfterViewInit {
  @Input() data: ProductDTO[] = [];
  @Input() total = 0;
  @Input() pageSize = 20;
  @Input() pageIndex = 0;
  @Input() sortActive = '';
  @Input() sortDir: 'asc' | 'desc' = 'asc';

  @Output() pageChange      = new EventEmitter<{page: number; size: number}>();
  @Output() sortChange      = new EventEmitter<{active: string; direction: string}>();
  @Output() filterChange    = new EventEmitter<UIFieldFilter[]>();

  @ViewChild(MatPaginator) paginator!: MatPaginator;
  @ViewChild(MatSort)      sort!: MatSort;
  @ViewChild('createdDtInput', { read: ElementRef }) createdDtInput!: ElementRef;

  private columnFilters: Record<string,string> = {};

  ngAfterViewInit(): void {
    // page event
    this.paginator.page.pipe(
      tap(e => this.pageChange.emit({ page: e.pageIndex + 1, size: e.pageSize }))
    ).subscribe();
    // sort event
    this.sort.sortChange.pipe(
      tap(e => { this.paginator.pageIndex = 0; this.sortChange.emit({ active: e.active, direction: e.direction }); })
    ).subscribe();
    // filter event
    const dateKeydown$ = fromEvent<KeyboardEvent>(this.createdDtInput.nativeElement,'keydown').pipe(
      map(() => this.createdDtInput.nativeElement.value.trim()),
      debounceTime(300),
      distinctUntilChanged(),
      tap(value => {
        this.paginator.pageIndex = 0;
        if (value) this.columnFilters['CreatedDtPattern'] = value;
        else delete this.columnFilters['CreatedDtPattern'];
        const filters: UIFieldFilter[] = [];
        Object.entries(this.columnFilters).forEach(([field, val]) => {
          filters.push({ field, operator: FilterOperator.Contains, value: val });
        });
        this.filterChange.emit(filters);
      })
    );

    merge(
      dateKeydown$.pipe(tap()),
      this.paginator.page.pipe(startWith(null)),
      this.sort.sortChange.pipe(startWith(null))
    ).subscribe();
  }
}

// app-main-table.component.ts  (parent)
import { Component, OnInit } from '@angular/core';
import { ProductPaginationService } from './product-pagination.service';
import { UIFieldFilter, UIPageDTO, FilterOperator } from './models/filter.model';

@Component({
  selector: 'app-main-table',
  template: `
    <app-product-table
      [data]="data"
      [total]="total"
      [pageSize]="pageSize"
      [pageIndex]="pageIndex"
      [sortActive]="sortActive"
      [sortDir]="sortDir"
      (pageChange)="onPage($event)"
      (sortChange)="onSort($event)"
      (filterChange)="onFilter($event)">
    </app-product-table>
  `
})
export class AppMainTableComponent implements OnInit {
  data: any[] = [];
  total = 0;
  pageSize = 20;
  pageIndex = 1;
  sortActive = '';
  sortDir: 'asc'|'desc' = 'asc';
  private filters: UIFieldFilter[] = [];

  constructor(private service: ProductPaginationService) {}

  ngOnInit() {
    this.load();
  }

  onPage(event: {page: number; size: number}) {
    this.pageIndex = event.page;
    this.pageSize  = event.size;
    this.load();
  }

  onSort(event: {active: string; direction: string}) {
    this.sortActive = event.active;
    this.sortDir    = event.direction as 'asc'|'desc';
    this.load();
  }

  onFilter(filters: UIFieldFilter[]) {
    this.filters = filters;
    this.pageIndex = 1;
    this.load();
  }

  private load() {
    const dto: UIPageDTO = {
      pageNumber: this.pageIndex,
      pageSize:   this.pageSize,
      sortBy:     this.sortActive,
      sortDesc:   this.sortDir === 'desc',
      filters:    this.filters
    };
    this.service.getProducts(dto).subscribe(res => {
      this.data  = res.items;
      this.total = res.totalCount;
    });
  }
}
